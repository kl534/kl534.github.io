<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little League Stat Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937; /* Dark gray */
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb; /* Light gray border */
            padding-bottom: 0.5rem;
        }
        label {
            font-weight: 500;
            color: #374151; /* Medium gray */
        }
        input[type="text"], input[type="number"], select {
            border: 1px solid #d1d5db; /* Gray border */
            border-radius: 4px;
            padding: 8px 12px;
            width: 100%;
            margin-top: 4px;
            box-sizing: border-box;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none; /* Safari and Chrome */
            margin: 0;
        }
        button {
            background-color: #3b82f6; /* Blue */
            color: white;
            font-weight: 500;
            padding: 10px 15px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2563eb; /* Darker blue */
        }
        button:disabled {
            background-color: #9ca3af; /* Gray for disabled */
            cursor: not-allowed;
        }
        .delete-btn {
            background-color: #ef4444; /* Red */
        }
        .delete-btn:hover {
            background-color: #dc2626; /* Darker red */
        }
        .move-btn {
            background-color: #6b7280; /* Gray */
            padding: 4px 8px;
            font-size: 0.8rem;
            margin: 0 2px;
        }
        .move-btn:hover {
            background-color: #4b5563; /* Darker Gray */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            border: 1px solid #e5e7eb; /* Light gray border */
            padding: 10px;
            text-align: left;
            font-size: 0.9rem;
            vertical-align: middle; /* Align content vertically */
        }
        th {
            background-color: #f9fafb; /* Very light gray */
            font-weight: 600;
        }
        .stats-table td {
            text-align: center;
        }
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top */
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 90%; /* For smaller screens */
        }
        #loadingIndicator {
            display: none; /* Hidden by default */
            margin-top: 1rem;
            font-weight: 500;
            color: #1d4ed8; /* Darker blue for text */
        }
        .chart-container {
            position: relative;
            height: 350px; 
            width: 100%;   
            margin-bottom: 1rem; 
        }
        .order-buttons button {
            min-width: 30px; /* Ensure buttons have some width */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Little League Stat Simulator</h1>

        <div class="card">
            <h2>Roster Input</h2>
            <p class="text-sm text-gray-600 mb-3">Enter your players below. The lineup order can be adjusted using the ▲/▼ buttons. Data is saved automatically.</p>
            <table id="rosterTable">
                <thead>
                    <tr>
                        <th>Player Name</th>
                        <th>At-Bats (AB)</th>
                        <th>Hits (H)</th>
                        <th>Total Bases (TB)</th>
                        <th>Strikeouts (SO)</th>
                        <th class="w-24 text-center">Order</th> {/* Added Order column */}
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="rosterTableBody">
                    </tbody>
            </table>
            <button id="addPlayerBtn" class="mt-4">Add Player</button>
        </div>

        <div class="card">
            <h2>Game Simulation (100,000 Games)</h2>
            <button id="runSimulationBtn">Run Simulation</button>
            <div id="loadingIndicator">Simulating... Please wait. This might take a moment.</div>
            <div id="simulationResults" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-2">Run Distribution Histogram</h3>
                <div class="chart-container">
                    <canvas id="runsHistogramChart"></canvas> </div>
                <h3 class="text-xl font-semibold mt-6 mb-2">Run Percentages</h3>
                <table id="runPercentagesTable" class="stats-table">
                    <thead><tr><th>Runs Scored</th><th>Frequency</th><th>Percentage</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="card">
            <h2>Lineup Optimization</h2>
            <div>
                <label for="optimizationSimsSelect" class="block mb-1">Simulations per Lineup:</label>
                <select id="optimizationSimsSelect">
                    <option value="100">100 (Fastest)</option>
                    <option value="500">500</option>
                    <option value="1000" selected>1000 (Recommended)</option>
                    <option value="2000">2000</option> 
                    <option value="5000">5000 (Most Accurate)</option>
                </select>
            </div>
            <button id="optimizeLineupBtn" class="mt-4">Optimize Lineup</button>
            <div id="optimizationLoadingIndicator" class="hidden mt-2 font-medium text-blue-600">Optimizing... This could take some time.</div>
            <div id="optimizationResult" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-1">Optimized Lineup:</h3>
                <ol id="optimizedLineupList" class="list-decimal list-inside pl-2 bg-gray-50 p-3 rounded"></ol>
                <p class="mt-2 font-semibold">Expected Runs: <span id="expectedRunsValue" class="text-blue-700"></span></p>
            </div>
        </div>

        <div class="card">
            <h2>Share Roster</h2>
            <button id="generateShareUrlBtn">Generate Shareable URL</button>
            <div class="mt-2 flex items-center space-x-2">
                <input type="text" id="shareUrlInput" readonly class="bg-gray-100 flex-grow">
                <button id="copyUrlBtn">Copy URL</button>
            </div>
        </div>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <p id="modalMessageText"></p>
            <button id="closeModalBtn" class="mt-4">Close</button>
        </div>
    </div>

    <script>
        // --- Global State & Constants ---
        let globalRoster = [];
        let runsChart = null;
        const MAX_RUNS_PER_INNING = 5;
        const NUM_INNINGS = 6;
        const MAX_BRUTE_FORCE_OPTIMIZATION_SIZE = 8;

        // --- DOM Elements ---
        const rosterTableBody = document.getElementById('rosterTableBody');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const runSimulationBtn = document.getElementById('runSimulationBtn');
        const simulationResultsDiv = document.getElementById('simulationResults');
        const runsHistogramChartCtx = document.getElementById('runsHistogramChart').getContext('2d');
        const runPercentagesTableBody = document.getElementById('runPercentagesTable').querySelector('tbody');
        const optimizationSimsSelect = document.getElementById('optimizationSimsSelect');
        const optimizeLineupBtn = document.getElementById('optimizeLineupBtn');
        const optimizationResultDiv = document.getElementById('optimizationResult');
        const optimizedLineupList = document.getElementById('optimizedLineupList');
        const expectedRunsValue = document.getElementById('expectedRunsValue');
        const generateShareUrlBtn = document.getElementById('generateShareUrlBtn');
        const shareUrlInput = document.getElementById('shareUrlInput');
        const copyUrlBtn = document.getElementById('copyUrlBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const optimizationLoadingIndicator = document.getElementById('optimizationLoadingIndicator');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const closeModalBtn = document.getElementById('closeModalBtn');

        // --- Utility Functions ---
        function showMessage(message) {
            modalMessageText.textContent = message;
            messageModal.classList.remove('hidden');
        }
        function hideMessage() {
            messageModal.classList.add('hidden');
        }
        closeModalBtn.addEventListener('click', hideMessage);

        // --- Roster Management ---
        function addPlayerRow(player = { name: '', ab: '', h: '', tb: '', so: '' }, index = -1, totalPlayers = 0) {
            const row = rosterTableBody.insertRow(index); // Insert at specific index if provided
            const name = player.name || '';
            const ab = player.ab === undefined || player.ab === null ? '' : player.ab;
            const h = player.h === undefined || player.h === null ? '' : player.h;
            const tb = player.tb === undefined || player.tb === null ? '' : player.tb;
            const so = player.so === undefined || player.so === null ? '' : player.so;

            row.innerHTML = `
                <td><input type="text" class="player-name" value="${name}" placeholder="Player Name"></td>
                <td><input type="number" class="player-ab" value="${ab}" placeholder="e.g. 100" min="0"></td>
                <td><input type="number" class="player-h" value="${h}" placeholder="e.g. 30" min="0"></td>
                <td><input type="number" class="player-tb" value="${tb}" placeholder="e.g. 50" min="0"></td>
                <td><input type="number" class="player-so" value="${so}" placeholder="e.g. 20" min="0"></td>
                <td class="text-center order-buttons">
                    <button class="move-btn move-up-btn" title="Move Up">▲</button>
                    <button class="move-btn move-down-btn" title="Move Down">▼</button>
                </td>
                <td><button class="delete-btn text-sm px-2 py-1">Delete</button></td>
            `;
            
            const currentRowIndex = Array.from(rosterTableBody.rows).indexOf(row);

            const upBtn = row.querySelector('.move-up-btn');
            const downBtn = row.querySelector('.move-down-btn');

            upBtn.addEventListener('click', () => movePlayer(currentRowIndex, -1));
            downBtn.addEventListener('click', () => movePlayer(currentRowIndex, 1));
            
            // Disable buttons appropriately - this will be handled by renderRosterFromGlobal more reliably
            // upBtn.disabled = currentRowIndex === 0;
            // downBtn.disabled = currentRowIndex === totalPlayers - 1;


            row.querySelector('.delete-btn').addEventListener('click', () => {
                deletePlayerRow(row);
            });

            row.querySelectorAll('input').forEach(input => {
                input.addEventListener('change', () => {
                    // Validate specific field on change for immediate feedback on *incorrect values*
                    validateRowOnInputChange(row); 
                    readTableIntoGlobalRoster(); // Update globalRoster
                    saveRosterToLocalStorage(); // Save changes
                });
                input.addEventListener('keyup', () => {
                    // Could add debounced validation here if needed, but change event is often enough
                    readTableIntoGlobalRoster();
                    saveRosterToLocalStorage();
                });
            });
        }
        
        function validateRowOnInputChange(row) {
            // This function provides immediate feedback for *incorrect values* in a row,
            // but not for mere incompleteness.
            const nameInput = row.querySelector('.player-name');
            const abInput = row.querySelector('.player-ab');
            const hInput = row.querySelector('.player-h');
            const tbInput = row.querySelector('.player-tb');
            const soInput = row.querySelector('.player-so');

            const name = nameInput.value.trim();
            const ab = abInput.value !== '' ? parseInt(abInput.value) : null;
            const h = hInput.value !== '' ? parseInt(hInput.value) : null;
            const tb = tbInput.value !== '' ? parseInt(tbInput.value) : null;
            const so = soInput.value !== '' ? parseInt(soInput.value) : null;
            
            let issueFound = false;

            if (ab !== null && ab < 0) { showMessage(`Player ${name || 'Unnamed'}: At-Bats (AB) must be non-negative.`); issueFound = true; abInput.focus();}
            if (h !== null && h < 0) { showMessage(`Player ${name || 'Unnamed'}: Hits (H) must be non-negative.`); issueFound = true; hInput.focus();}
            if (tb !== null && tb < 0) { showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be non-negative.`); issueFound = true; tbInput.focus();}
            if (so !== null && so < 0) { showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) must be non-negative.`); issueFound = true; soInput.focus();}

            if (!issueFound && ab !== null && h !== null && h > ab) {
                showMessage(`Player ${name || 'Unnamed'}: Hits (H) cannot exceed At-Bats (AB).`); hInput.focus();
            }
            if (!issueFound && h !== null && tb !== null && tb < h) {
                showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be at least Hits (H).`); tbInput.focus();
            }
            if (!issueFound && ab !== null && so !== null && so > ab) {
                showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) cannot exceed At-Bats (AB).`); soInput.focus();
            }
            if (!issueFound && ab !== null && h !== null && so !== null && (h + so) > ab) {
                 showMessage(`Player ${name || 'Unnamed'}: Hits (H) plus Strikeouts (SO) cannot exceed At-Bats (AB).`); soInput.focus();
            }
        }


        function movePlayer(rowIndex, direction) {
            if (direction === -1 && rowIndex > 0) { // Move Up
                [globalRoster[rowIndex], globalRoster[rowIndex - 1]] = [globalRoster[rowIndex - 1], globalRoster[rowIndex]];
            } else if (direction === 1 && rowIndex < globalRoster.length - 1) { // Move Down
                [globalRoster[rowIndex], globalRoster[rowIndex + 1]] = [globalRoster[rowIndex + 1], globalRoster[rowIndex]];
            }
            renderRosterFromGlobal();
            saveRosterToLocalStorage();
        }

        function deletePlayerRow(rowElement) {
            const rowIndex = Array.from(rosterTableBody.rows).indexOf(rowElement);
            if (rowIndex > -1) {
                globalRoster.splice(rowIndex, 1); // Remove from globalRoster first
                // rosterTableBody.deleteRow(rowIndex); // This is now handled by renderRosterFromGlobal
                renderRosterFromGlobal(); // Re-render to update table and button states
                saveRosterToLocalStorage();
            }
        }
        
        function readTableIntoGlobalRoster() {
            const newRoster = [];
            const rows = rosterTableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const name = rows[i].querySelector('.player-name').value.trim();
                const abStr = rows[i].querySelector('.player-ab').value;
                const hStr = rows[i].querySelector('.player-h').value;
                const tbStr = rows[i].querySelector('.player-tb').value;
                const soStr = rows[i].querySelector('.player-so').value;

                // Store raw string values or parsed numbers if available.
                // This allows saving incomplete data. Validation for processing happens later.
                newRoster.push({
                    name: name,
                    ab: abStr === '' ? '' : parseInt(abStr), // Keep as '' if empty, else parse
                    h:  hStr === '' ? '' : parseInt(hStr),
                    tb: tbStr === '' ? '' : parseInt(tbStr),
                    so: soStr === '' ? '' : parseInt(soStr),
                });
            }
            globalRoster = newRoster;
        }
        
        function renderRosterFromGlobal() {
            rosterTableBody.innerHTML = ''; // Clear existing rows
            if (globalRoster.length === 0) { // If roster becomes empty, add one blank row
                addPlayerRow({}, 0, 1); // Pass index and total for button state
            } else {
                globalRoster.forEach((player, index) => {
                    addPlayerRow(player, index, globalRoster.length);
                });
            }
            updateMoveButtonStates();
        }

        function updateMoveButtonStates() {
            const rows = rosterTableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const upBtn = rows[i].querySelector('.move-up-btn');
                const downBtn = rows[i].querySelector('.move-down-btn');
                if (upBtn) upBtn.disabled = (i === 0);
                if (downBtn) downBtn.disabled = (i === rows.length - 1);
            }
        }


        function saveRosterToLocalStorage() {
            // Ensure globalRoster is up-to-date before saving
            // readTableIntoGlobalRoster(); // This might be redundant if called by event handlers
            localStorage.setItem('littleLeagueRoster', JSON.stringify(globalRoster));
        }

        function loadRosterFromLocalStorage() {
            const savedRoster = localStorage.getItem('littleLeagueRoster');
            if (savedRoster) {
                try {
                    const parsedRoster = JSON.parse(savedRoster);
                    if (Array.isArray(parsedRoster)) {
                        globalRoster = parsedRoster.map(p => ({ // Ensure all fields exist
                            name: p.name || '',
                            ab: p.ab === undefined || p.ab === null ? '' : p.ab,
                            h:  p.h  === undefined || p.h  === null ? '' : p.h,
                            tb: p.tb === undefined || p.tb === null ? '' : p.tb,
                            so: p.so === undefined || p.so === null ? '' : p.so,
                        }));
                    } else { globalRoster = []; }
                } catch (e) {
                    console.error("Error parsing roster from local storage:", e);
                    globalRoster = []; 
                }
            }
            renderRosterFromGlobal(); // This will add an empty row if globalRoster is empty
        }

        function validateRosterForProcessing() {
            readTableIntoGlobalRoster(); // Ensure globalRoster is fresh from table
            if (globalRoster.length === 0) {
                showMessage("Roster is empty. Please add players first.");
                return false;
            }

            let firstErrorPlayerName = null;
            let firstErrorMessage = "";

            for (const player of globalRoster) {
                if (!player.name.trim()) {
                    firstErrorMessage = "One or more players is missing a name.";
                    break; 
                }
                const { name, ab, h, tb, so } = player;
                if (ab === '' || h === '' || tb === '' || so === '') {
                    firstErrorPlayerName = name;
                    firstErrorMessage = `Player ${name} has incomplete stats. All fields (AB, H, TB, SO) are required.`;
                    break;
                }
                if (isNaN(ab) || isNaN(h) || isNaN(tb) || isNaN(so)) {
                    firstErrorPlayerName = name;
                    firstErrorMessage = `Player ${name} has non-numeric stat entries.`;
                    break;
                }
                if (ab < 0 || h < 0 || tb < 0 || so < 0) {
                     firstErrorPlayerName = name;
                     firstErrorMessage = `Player ${name}: Stats must be non-negative.`; break;
                }
                if (h > ab) {
                    firstErrorPlayerName = name;
                    firstErrorMessage = `Player ${name}: Hits (H) cannot exceed At-Bats (AB).`; break;
                }
                if (tb < h) {
                    firstErrorPlayerName = name;
                    firstErrorMessage = `Player ${name}: Total Bases (TB) must be at least Hits (H).`; break;
                }
                if (so > ab) {
                    firstErrorPlayerName = name;
                    firstErrorMessage = `Player ${name}: Strikeouts (SO) cannot exceed At-Bats (AB).`; break;
                }
                if ((h + so) > ab) {
                    firstErrorPlayerName = name;
                    firstErrorMessage = `Player ${name}: Hits (H) plus Strikeouts (SO) cannot exceed At-Bats (AB).`; break;
                }
            }

            if (firstErrorMessage) {
                showMessage(firstErrorMessage);
                // Try to focus the first problematic input if possible (more complex to implement robustly here)
                return false;
            }
            return true;
        }


        function loadRosterFromURL() {
            const params = new URLSearchParams(window.location.search);
            const rosterData = params.get('roster');
            if (rosterData) {
                try {
                    const decodedRoster = JSON.parse(atob(rosterData));
                    if (Array.isArray(decodedRoster)) {
                        const validatedRoster = decodedRoster.map(p => ({ // Ensure structure
                            name: p.name || '',
                            ab: p.ab === undefined || p.ab === null ? '' : p.ab,
                            h:  p.h  === undefined || p.h  === null ? '' : p.h,
                            tb: p.tb === undefined || p.tb === null ? '' : p.tb,
                            so: p.so === undefined || p.so === null ? '' : p.so,
                        })).filter(p => { // Basic sanity check on values for URL load
                            const abNum = parseInt(p.ab); const hNum = parseInt(p.h);
                            const tbNum = parseInt(p.tb); const soNum = parseInt(p.so);
                            return !( (p.ab !== '' && (isNaN(abNum) || abNum < 0)) ||
                                      (p.h !== '' && (isNaN(hNum) || hNum < 0)) ||
                                      (p.tb !== '' && (isNaN(tbNum) || tbNum < 0)) ||
                                      (p.so !== '' && (isNaN(soNum) || soNum < 0)) ||
                                      (p.ab !== '' && p.h !== '' && hNum > abNum) ||
                                      (p.h !== '' && p.tb !== '' && tbNum < hNum) ||
                                      (p.ab !== '' && p.so !== '' && soNum > abNum) ||
                                      (p.ab !== '' && p.h !== '' && p.so !== '' && (hNum + soNum) > abNum)
                                    );
                        });

                        if (validatedRoster.length !== decodedRoster.length) {
                            showMessage("Some player data from the URL was invalid or incomplete and has been omitted/adjusted.");
                        }

                        if (validatedRoster.length > 0) {
                            globalRoster = validatedRoster;
                            renderRosterFromGlobal();
                            saveRosterToLocalStorage(); 
                            showMessage("Roster loaded from URL!");
                            window.history.replaceState({}, document.title, window.location.pathname);
                            return; 
                        } else if (decodedRoster.length > 0) {
                             showMessage("Roster data in URL was invalid. Loading from local storage instead.");
                        }
                    } else {
                         showMessage("Invalid roster format in URL. Loading from local storage instead.");
                    }
                } catch (e) {
                    console.error("Error parsing roster data from URL:", e);
                    showMessage("Could not load roster from URL: Corrupted data. Loading from local storage.");
                }
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            loadRosterFromLocalStorage();
        }
        
        generateShareUrlBtn.addEventListener('click', () => {
            readTableIntoGlobalRoster(); // Ensure globalRoster is current
            if (!validateRosterForProcessing()) { // Use the strict validation before sharing
                 showMessage("Please ensure all player data is complete and valid before generating a share URL.");
                 return;
            }
            if (globalRoster.length === 0) {
                showMessage("Roster is empty. Add players to share.");
                return;
            }
            const jsonRoster = JSON.stringify(globalRoster);
            const base64Roster = btoa(jsonRoster); 
            const url = `${window.location.origin}${window.location.pathname}?roster=${base64Roster}`;
            shareUrlInput.value = url;
        });

        copyUrlBtn.addEventListener('click', () => {
            if (shareUrlInput.value) {
                shareUrlInput.select();
                try {
                    document.execCommand('copy'); 
                    showMessage("URL copied to clipboard!");
                } catch (err) {
                    navigator.clipboard.writeText(shareUrlInput.value).then(() => {
                        showMessage("URL copied to clipboard!");
                    }).catch(e => {
                        showMessage("Failed to copy URL. Please copy it manually.");
                        console.error("Copy failed: ", e);
                    });
                }
            } else {
                showMessage("Generate a URL first.");
            }
        });

        // --- Probability Calculation ---
        function calculatePlayerProbs(player) {
            // Player object here is expected to have numeric, validated stats
            if (!player || typeof player.ab !== 'number' || player.ab === 0 || 
                typeof player.h !== 'number' || typeof player.tb !== 'number' || typeof player.so !== 'number') {
                // This case should ideally be caught by validateRosterForProcessing
                console.warn("Invalid player data passed to calculatePlayerProbs:", player);
                return { ...player, name: player.name || "Unknown Player", P_SO: 0, P_Out_Other: 1, P_1B: 0, P_2B: 0, P_HR: 0, C_SO: 0, C_Out_Other: 1, C_1B: 1, C_2B: 1, C_HR: 1 };
            }

            let { ab, h, tb, so } = player; // These are now guaranteed numbers by validateRosterForProcessing

            const avg = h / ab;
            const slg = tb / ab;
            let iso = slg - avg;
            if (iso < 0) iso = 0; 

            let p_hr = 0, p_2b = 0, p_1b = 0;

            if (avg > 0) { 
                const alpha_hr_vs_2b_bases = 3.0; 
                p_hr = iso / (alpha_hr_vs_2b_bases + 1.0); 
                p_2b = iso - 3 * p_hr; 
                
                if (p_2b < 0) { 
                    p_hr = iso / 3.0; 
                    p_2b = 0;
                }

                if (p_hr + p_2b > avg) {
                    const total_xbh_prob_raw = p_hr + p_2b;
                    if (total_xbh_prob_raw > 0) {
                        // Prorate XBH to fit within AVG, leaving some room for singles if possible
                        const target_xbh_sum = avg * 0.9; // Example: allow 10% of AVG for singles at minimum
                        const scale_xbh = Math.min(1, target_xbh_sum / total_xbh_prob_raw);
                        p_hr *= scale_xbh;
                        p_2b *= scale_xbh;
                    } else {
                        p_hr = 0; p_2b = 0;
                    }
                }
                
                p_1b = avg - p_hr - p_2b;

                p_hr = Math.max(0, p_hr);
                p_2b = Math.max(0, p_2b);
                p_1b = Math.max(0, p_1b); // Recalculate p_1b after adjustments

                const current_sum_hit_probs = p_1b + p_2b + p_hr;
                if (current_sum_hit_probs > 0 && avg > 0 && Math.abs(current_sum_hit_probs - avg) > 1e-9) {
                    const scale = avg / current_sum_hit_probs;
                    p_1b *= scale;
                    p_2b *= scale;
                    p_hr *= scale;
                } else if (avg > 0 && current_sum_hit_probs === 0) { 
                    p_1b = avg; 
                    p_2b = 0;
                    p_hr = 0;
                }
            }
            
            let p_so_calc = so / ab;
            let p_other_out_calc = (ab - h - so) / ab;

            p_so_calc = Math.max(0, p_so_calc);
            p_other_out_calc = Math.max(0, p_other_out_calc);
            
            // Ensure sum of P_SO, P_Other_Out, and AVG (total hit prob) is 1.0
            let total_non_hit_prob = p_so_calc + p_other_out_calc;
            let target_non_hit_prob = 1.0 - avg;

            if (Math.abs(total_non_hit_prob - target_non_hit_prob) > 1e-9) {
                if (target_non_hit_prob < 0) target_non_hit_prob = 0; // Should not happen if h <= ab

                if (total_non_hit_prob > 0) {
                    p_so_calc = (p_so_calc / total_non_hit_prob) * target_non_hit_prob;
                    p_other_out_calc = (p_other_out_calc / total_non_hit_prob) * target_non_hit_prob;
                } else if (target_non_hit_prob > 0) { // If somehow both were 0 but should sum to >0
                    // Distribute based on original SO count vs other outs (AB-H-SO)
                    const original_other_outs = ab - h - so;
                    if (so + original_other_outs > 0) {
                        p_so_calc = (so / (so + original_other_outs)) * target_non_hit_prob;
                        p_other_out_calc = (original_other_outs / (so + original_other_outs)) * target_non_hit_prob;
                    } else { // Only hits, so non_hit_prob is 0
                         p_so_calc = 0; p_other_out_calc = 0;
                    }
                }
            }
            
            // Final check and normalization of ALL probabilities
            let all_probs_final = [p_1b, p_2b, p_hr, p_so_calc, p_other_out_calc];
            let sum_all_probs_final = all_probs_final.reduce((s, val_p) => s + val_p, 0);

            if (Math.abs(sum_all_probs_final - 1.0) > 1e-9) {
                if (sum_all_probs_final > 0) {
                    const scaleFactor = 1.0 / sum_all_probs_final;
                    p_1b *= scaleFactor;
                    p_2b *= scaleFactor;
                    p_hr *= scaleFactor;
                    p_so_calc *= scaleFactor;
                    p_other_out_calc *= scaleFactor;
                } else { // Should not happen if ab > 0
                    p_other_out_calc = 1.0; // Default to an out if all else fails
                    p_1b = p_2b = p_hr = p_so_calc = 0;
                }
            }
            // Ensure p_other_out_calc is not negative after scaling (due to floating point)
            p_other_out_calc = Math.max(0, 1.0 - (p_1b + p_2b + p_hr + p_so_calc));


            return {
                ...player, 
                P_SO: p_so_calc, P_Out_Other: p_other_out_calc, P_1B: p_1b, P_2B: p_2b, P_HR: p_hr,
                C_SO: p_so_calc,
                C_Out_Other: p_so_calc + p_other_out_calc,
                C_1B: p_so_calc + p_other_out_calc + p_1b,
                C_2B: p_so_calc + p_other_out_calc + p_1b + p_2b,
                C_HR: 1.0 
            };
        }


        // --- Game Simulation Logic --- (Unchanged from previous version, but included for completeness)
        function getPAOutcome(playerProbs) {
            const r = Math.random();
            if (r < playerProbs.C_SO) return "SO";
            if (r < playerProbs.C_Out_Other) return "OutOther";
            if (r < playerProbs.C_1B) return "1B";
            if (r < playerProbs.C_2B) return "2B";
            return "HR"; 
        }

        function simulateGame(lineupWithProbs) {
            if (!lineupWithProbs || lineupWithProbs.length === 0) return 0;

            let totalGameRuns = 0;
            let currentBatterIdx = 0;

            for (let inning = 0; inning < NUM_INNINGS; inning++) {
                let outs = 0;
                let inningRuns = 0;
                let bases = [0, 0, 0]; 

                while (outs < 3 && inningRuns < MAX_RUNS_PER_INNING) {
                    if (lineupWithProbs.length === 0) break; 
                    const batterProbs = lineupWithProbs[currentBatterIdx % lineupWithProbs.length];
                    const outcome = getPAOutcome(batterProbs);
                    let runsThisPA = 0;

                    if (outcome === "SO" || outcome === "OutOther") {
                        outs++;
                    } else { 
                        if (outcome === "HR") {
                            runsThisPA++; 
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } 
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } 
                            if (bases[0]) { runsThisPA++; bases[0] = 0; } 
                        } else if (outcome === "2B") {
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } 
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } 
                            if (bases[0]) { bases[2] = 1; bases[0] = 0; } 
                            bases[1] = 1; 
                        } else if (outcome === "1B") {
                            if (bases[0] && bases[1] && bases[2]) { // Bases loaded
                                runsThisPA++; // Runner from 3rd scores
                                // bases[2] = 1 (from 2nd); bases[1] = 1 (from 1st); bases[0] = 1 (batter)
                            } else if (bases[0] && bases[1]) { // 1st and 2nd occupied
                                if (bases[2]) runsThisPA++; // Runner from 3rd scores (should not happen if 1st,2nd full and not 3rd)
                                bases[2] = 1; // Runner from 2nd to 3rd
                                // bases[1] = 1 (runner from 1st to 2nd)
                                // bases[0] = 1 (batter to 1st)
                            } else if (bases[0]) { // Runner on 1st only
                                if (bases[2]) { runsThisPA++; bases[2] = 0;}
                                if (bases[1]) { bases[2] = 1; bases[1] = 0;}
                                bases[1] = 1; // Runner from 1st to 2nd
                                bases[0] = 1; // Batter to 1st
                            } else if (bases[1]) { // Runner on 2nd only
                                 if (bases[2]) { runsThisPA++; bases[2] = 0;}
                                 bases[2] = 1; // Runner from 2nd to 3rd
                                 bases[1] = 0;
                                 bases[0] = 1; // Batter to 1st
                            } else if (bases[2]) { // Runner on 3rd only
                                runsThisPA++; bases[2] = 0;
                                bases[0] = 1; // Batter to 1st
                            } else { // Bases empty
                                bases[0] = 1; // Batter to 1st
                            }
                        }
                    }
                    
                    inningRuns += runsThisPA;
                    if (inningRuns >= MAX_RUNS_PER_INNING) {
                        inningRuns = MAX_RUNS_PER_INNING; 
                        totalGameRuns += inningRuns;
                        currentBatterIdx = (currentBatterIdx + 1); 
                        break; 
                    }
                    currentBatterIdx = (currentBatterIdx + 1); 
                } 
                
                if (inningRuns < MAX_RUNS_PER_INNING) { 
                     totalGameRuns += inningRuns;
                }
            } 
            return totalGameRuns;
        }
        
        async function runManySimulations(lineup, numSims) {
            return new Promise(resolve => {
                let totalRunsAcrossSims = 0;
                // Ensure player stats are numbers before calculating probabilities
                const validatedLineup = lineup.map(p => ({
                    ...p,
                    ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
                }));

                const processedLineup = validatedLineup.map(p => calculatePlayerProbs(p));
                
                if (processedLineup.some(p => !p || typeof p.P_SO === 'undefined')) {
                    console.error("Invalid player data found in lineup during simulation batch:", processedLineup.filter(p => !p || typeof p.P_SO === 'undefined'));
                    showMessage("Error: Invalid player data detected. Cannot run simulations.");
                    resolve(0); 
                    return;
                }

                for (let i = 0; i < numSims; i++) {
                    totalRunsAcrossSims += simulateGame(processedLineup);
                }
                resolve(totalRunsAcrossSims / numSims);
            });
        }

        runSimulationBtn.addEventListener('click', async () => {
            if (!validateRosterForProcessing()) return; // Strict validation before processing
            
            // globalRoster is now guaranteed to have players with complete, numeric stats
            const rosterForSim = globalRoster.map(p => ({
                ...p,
                ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
            }));

            loadingIndicator.style.display = 'block';
            simulationResultsDiv.classList.add('hidden'); 
            runSimulationBtn.disabled = true;
            optimizeLineupBtn.disabled = true; 

            await new Promise(resolve => setTimeout(resolve, 50));

            const processedRoster = rosterForSim.map(p => calculatePlayerProbs(p));
            // This check should be redundant if validateRosterForProcessing and calculatePlayerProbs are robust
            if (processedRoster.some(p => !p || typeof p.P_SO === 'undefined')) { 
                 showMessage("Error processing player data after final validation. Please check inputs.");
                 loadingIndicator.style.display = 'none';
                 runSimulationBtn.disabled = false;
                 optimizeLineupBtn.disabled = false;
                 return;
            }

            const numSimulations = 100000;
            const runCounts = {}; 
            const batchSize = 5000;
            let simsDone = 0;

            function simulateBatch() {
                for (let i = 0; i < batchSize && simsDone < numSimulations; i++) {
                    const runs = simulateGame(processedRoster);
                    runCounts[runs] = (runCounts[runs] || 0) + 1;
                    simsDone++;
                }

                if (simsDone < numSimulations) {
                    loadingIndicator.textContent = `Simulating... ${((simsDone / numSimulations) * 100).toFixed(0)}% complete.`;
                    setTimeout(simulateBatch, 0); 
                } else {
                    loadingIndicator.textContent = 'Simulating... Please wait. This might take a moment.'; 
                    loadingIndicator.style.display = 'none';

                    const labels = [];
                    const data = [];
                    runPercentagesTableBody.innerHTML = ''; 

                    let practicalMaxRuns = 0;
                    for (const runs in runCounts) {
                        if (runCounts[runs] > 0) {
                            practicalMaxRuns = Math.max(practicalMaxRuns, parseInt(runs));
                        }
                    }
                    const displayMaxRuns = Math.max(15, practicalMaxRuns);

                    for (let i = 0; i <= displayMaxRuns; i++) {
                        const count = runCounts[i] || 0;
                        labels.push(i.toString());
                        data.push(count);
                        if (count > 0 || i <= displayMaxRuns) { 
                             const percentage = ((count / numSimulations) * 100).toFixed(2);
                             const row = runPercentagesTableBody.insertRow();
                             row.innerHTML = `<td>${i}</td><td>${count}</td><td>${percentage}%</td>`;
                        }
                    }
                    
                    if (runsChart) { runsChart.destroy(); }
                    runsChart = new Chart(runsHistogramChartCtx, {
                        type: 'bar',
                        data: { labels: labels, datasets: [{ label: 'Frequency of Runs Scored', data: data, backgroundColor: 'rgba(59, 130, 246, 0.7)', borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1 }] },
                        options: { scales: { y: { beginAtZero: true, title: { display: true, text: 'Number of Games' } }, x: { title: { display: true, text: 'Runs Scored in a Game' } } }, responsive: true, maintainAspectRatio: false }
                    });

                    simulationResultsDiv.classList.remove('hidden');
                    runSimulationBtn.disabled = false;
                    optimizeLineupBtn.disabled = false;
                }
            }
            simulateBatch(); 
        });

        // --- Lineup Optimization --- (Largely unchanged logic, but uses validated roster)
        function getAllPermutations(arr) { 
            if (arr.length === 0) return [[]];
            if (arr.length === 1) return [[...arr]]; 

            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const current = arr[i];
                const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
                const remainingPermuted = getAllPermutations(remaining);
                for (let j = 0; j < remainingPermuted.length; j++) {
                    result.push([current, ...remainingPermuted[j]]);
                }
            }
            return result;
        }
        
        optimizeLineupBtn.addEventListener('click', async () => {
            if (!validateRosterForProcessing()) return; // Strict validation

            const rosterForOpt = globalRoster.map(p => ({ // Ensure numeric types for processing
                ...p,
                ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
            }));

            if (rosterForOpt.length < 1) { 
                showMessage("Optimization requires at least one player.");
                return;
            }

            const numPlayers = rosterForOpt.length;
            const simsPerLineup = parseInt(optimizationSimsSelect.value);

            if (numPlayers > MAX_BRUTE_FORCE_OPTIMIZATION_SIZE && numPlayers * numPlayers * simsPerLineup > 2000000) { 
                 if (!confirm(`Optimizing a roster of ${numPlayers} players with ${simsPerLineup} simulations per lineup might take a very long time (potentially minutes). Continue?`)) {
                    return;
                }
            }

            optimizationLoadingIndicator.style.display = 'block';
            optimizationResultDiv.classList.add('hidden');
            optimizeLineupBtn.disabled = true;
            runSimulationBtn.disabled = true; 
            
            await new Promise(resolve => setTimeout(resolve, 50)); 

            let bestLineup = [];
            let bestExpectedRuns = -1;
            
            if (numPlayers === 1) {
                bestLineup = [...rosterForOpt]; 
                bestExpectedRuns = await runManySimulations(bestLineup, simsPerLineup);
            } else if (numPlayers <= MAX_BRUTE_FORCE_OPTIMIZATION_SIZE) {
                const numPerms = getAllPermutations(rosterForOpt).length; // Calculate for message
                optimizationLoadingIndicator.textContent = `Optimizing (brute force, ${numPerms} permutations)... This may take time.`;
                const permutations = getAllPermutations(rosterForOpt);
                let processedCount = 0;
                for (const perm of permutations) {
                    const avgRuns = await runManySimulations(perm, simsPerLineup);
                    if (avgRuns > bestExpectedRuns) {
                        bestExpectedRuns = avgRuns;
                        bestLineup = perm; 
                    }
                    processedCount++;
                    if (processedCount % Math.max(1, Math.floor(numPerms/20)) === 0 || processedCount === permutations.length) { 
                         optimizationLoadingIndicator.textContent = `Optimizing (brute force)... ${((processedCount/permutations.length)*100).toFixed(0)}%`;
                         await new Promise(resolve => setTimeout(resolve, 0)); 
                    }
                }
            } else {
                optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... This may take time.`;
                let currentLineup = [...rosterForOpt]; 
                for (let i = currentLineup.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentLineup[i], currentLineup[j]] = [currentLineup[j], currentLineup[i]];
                }

                bestLineup = [...currentLineup];
                bestExpectedRuns = await runManySimulations(currentLineup, simsPerLineup);

                const iterations = Math.min(1500, numPlayers * numPlayers * 3); 
                let noImprovementStreak = 0;
                const maxNoImprovementStreak = Math.max(50, numPlayers * 5); 

                for (let i = 0; i < iterations; i++) {
                    let tempLineup = [...bestLineup]; 
                    const idx1 = Math.floor(Math.random() * tempLineup.length);
                    let idx2 = Math.floor(Math.random() * tempLineup.length);
                    while (idx1 === idx2 && tempLineup.length > 1) { 
                        idx2 = Math.floor(Math.random() * tempLineup.length);
                    }
                    [tempLineup[idx1], tempLineup[idx2]] = [tempLineup[idx2], tempLineup[idx1]]; 
                    
                    const tempAvgRuns = await runManySimulations(tempLineup, simsPerLineup);
                    if (tempAvgRuns > bestExpectedRuns) {
                        bestExpectedRuns = tempAvgRuns;
                        bestLineup = [...tempLineup];
                        noImprovementStreak = 0; 
                    } else {
                        noImprovementStreak++;
                    }

                    if (i % 20 === 0 || i === iterations -1) { 
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Iteration ${i+1}/${iterations}`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 
                    }
                    if (noImprovementStreak > maxNoImprovementStreak) {
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Converged after ${i+1} iterations.`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 
                        break; 
                    }
                }
            }

            optimizedLineupList.innerHTML = '';
            if (bestLineup && bestLineup.length > 0) {
                bestLineup.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = player.name || "Unnamed Player"; 
                    optimizedLineupList.appendChild(li);
                });
                expectedRunsValue.textContent = bestExpectedRuns.toFixed(3);
            } else {
                 expectedRunsValue.textContent = "N/A";
                 optimizedLineupList.innerHTML = '<li>No valid lineup found.</li>';
            }
            
            optimizationResultDiv.classList.remove('hidden');
            optimizationLoadingIndicator.style.display = 'none';
            optimizationLoadingIndicator.textContent = 'Optimizing... This could take some time.'; 
            optimizeLineupBtn.disabled = false;
            runSimulationBtn.disabled = false;
        });

        // --- Initialization ---
        addPlayerBtn.addEventListener('click', () => {
            // Add to globalRoster first, then render.
            // This ensures the new player is part of the array before addPlayerRow tries to determine button states.
            globalRoster.push({ name: '', ab: '', h: '', tb: '', so: '' });
            renderRosterFromGlobal(); // This will render all players, including the new empty one
            saveRosterToLocalStorage(); // Save the new structure
            // Focus the name input of the newly added row
            if(rosterTableBody.lastElementChild) {
                const lastRowInputs = rosterTableBody.lastElementChild.querySelectorAll('input');
                if (lastRowInputs.length > 0) {
                    lastRowInputs[0].focus();
                }
            }
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            loadRosterFromURL(); 
        });

    </script>
</body>
</html>
