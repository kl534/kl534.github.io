<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little League Stat Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937; /* Dark gray */
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb; /* Light gray border */
            padding-bottom: 0.5rem;
        }
        label {
            font-weight: 500;
            color: #374151; /* Medium gray */
        }
        input[type="text"], input[type="number"], select {
            border: 1px solid #d1d5db; /* Gray border */
            border-radius: 4px;
            padding: 8px 12px;
            width: 100%;
            margin-top: 4px;
            box-sizing: border-box;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none; /* Safari and Chrome */
            margin: 0;
        }
        button {
            background-color: #3b82f6; /* Blue */
            color: white;
            font-weight: 500;
            padding: 10px 15px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2563eb; /* Darker blue */
        }
        .delete-btn {
            background-color: #ef4444; /* Red */
        }
        .delete-btn:hover {
            background-color: #dc2626; /* Darker red */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            border: 1px solid #e5e7eb; /* Light gray border */
            padding: 10px;
            text-align: left;
            font-size: 0.9rem;
        }
        th {
            background-color: #f9fafb; /* Very light gray */
            font-weight: 600;
        }
        .stats-table td {
            text-align: center;
        }
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top */
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        #loadingIndicator {
            display: none; /* Hidden by default */
            margin-top: 1rem;
            font-weight: 500;
            color: #1d4ed8; /* Darker blue for text */
        }
        /* Style for the chart container */
        .chart-container {
            position: relative;
            height: 350px; /* Adjust height as needed */
            width: 100%;   /* Take full width of its parent */
            margin-bottom: 1rem; /* Add some space below the chart */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Little League Stat Simulator</h1>

        <div class="card">
            <h2>Roster Input</h2>
            <table id="rosterTable">
                <thead>
                    <tr>
                        <th>Player Name</th>
                        <th>At-Bats (AB)</th>
                        <th>Hits (H)</th>
                        <th>Total Bases (TB)</th>
                        <th>Strikeouts (SO)</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="rosterTableBody">
                    </tbody>
            </table>
            <button id="addPlayerBtn" class="mt-4">Add Player</button>
        </div>

        <div class="card">
            <h2>Game Simulation (100,000 Games)</h2>
            <button id="runSimulationBtn">Run Simulation</button>
            <div id="loadingIndicator">Simulating... Please wait. This might take a moment.</div>
            <div id="simulationResults" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-2">Run Distribution Histogram</h3>
                <div class="chart-container">
                    <canvas id="runsHistogramChart"></canvas> </div>
                <h3 class="text-xl font-semibold mt-6 mb-2">Run Percentages</h3>
                <table id="runPercentagesTable" class="stats-table">
                    <thead><tr><th>Runs Scored</th><th>Frequency</th><th>Percentage</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="card">
            <h2>Lineup Optimization</h2>
            <div>
                <label for="optimizationSimsSelect" class="block mb-1">Simulations per Lineup:</label>
                <select id="optimizationSimsSelect">
                    <option value="100">100 (Fastest)</option>
                    <option value="500">500</option>
                    <option value="1000" selected>1000 (Recommended)</option>
                    <option value="2000">2000</option> <option value="5000">5000 (Most Accurate)</option>
                </select>
            </div>
            <button id="optimizeLineupBtn" class="mt-4">Optimize Lineup</button>
            <div id="optimizationLoadingIndicator" class="hidden mt-2 font-medium text-blue-600">Optimizing... This could take some time.</div>
            <div id="optimizationResult" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-1">Optimized Lineup:</h3>
                <ol id="optimizedLineupList" class="list-decimal list-inside pl-2 bg-gray-50 p-3 rounded"></ol>
                <p class="mt-2 font-semibold">Expected Runs: <span id="expectedRunsValue" class="text-blue-700"></span></p>
            </div>
        </div>

        <div class="card">
            <h2>Share Roster</h2>
            <button id="generateShareUrlBtn">Generate Shareable URL</button>
            <div class="mt-2 flex items-center space-x-2">
                <input type="text" id="shareUrlInput" readonly class="bg-gray-100 flex-grow">
                <button id="copyUrlBtn">Copy URL</button>
            </div>
        </div>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <p id="modalMessageText"></p>
            <button id="closeModalBtn" class="mt-4">Close</button>
        </div>
    </div>

    <script>
        // --- Global State & Constants ---
        let globalRoster = [];
        let runsChart = null;
        const MAX_RUNS_PER_INNING = 5;
        const NUM_INNINGS = 6;
        const MAX_BRUTE_FORCE_OPTIMIZATION_SIZE = 8; // Max roster size for brute-force permutation

        // --- DOM Elements ---
        const rosterTableBody = document.getElementById('rosterTableBody');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const runSimulationBtn = document.getElementById('runSimulationBtn');
        const simulationResultsDiv = document.getElementById('simulationResults');
        // Get the canvas context, not the canvas element itself for Chart.js
        const runsHistogramChartCtx = document.getElementById('runsHistogramChart').getContext('2d');
        const runPercentagesTableBody = document.getElementById('runPercentagesTable').querySelector('tbody');
        const optimizationSimsSelect = document.getElementById('optimizationSimsSelect');
        const optimizeLineupBtn = document.getElementById('optimizeLineupBtn');
        const optimizationResultDiv = document.getElementById('optimizationResult');
        const optimizedLineupList = document.getElementById('optimizedLineupList');
        const expectedRunsValue = document.getElementById('expectedRunsValue');
        const generateShareUrlBtn = document.getElementById('generateShareUrlBtn');
        const shareUrlInput = document.getElementById('shareUrlInput');
        const copyUrlBtn = document.getElementById('copyUrlBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const optimizationLoadingIndicator = document.getElementById('optimizationLoadingIndicator');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const closeModalBtn = document.getElementById('closeModalBtn');

        // --- Utility Functions ---
        function showMessage(message) {
            modalMessageText.textContent = message;
            messageModal.classList.remove('hidden');
        }

        function hideMessage() {
            messageModal.classList.add('hidden');
        }
        
        closeModalBtn.addEventListener('click', hideMessage);

        // --- Roster Management ---
        function addPlayerRow(player = { name: '', ab: '', h: '', tb: '', so: '' }) {
            const row = rosterTableBody.insertRow();
            row.innerHTML = `
                <td><input type="text" class="player-name" value="${player.name}" placeholder="Player Name"></td>
                <td><input type="number" class="player-ab" value="${player.ab}" placeholder="e.g. 100" min="0"></td>
                <td><input type="number" class="player-h" value="${player.h}" placeholder="e.g. 30" min="0"></td>
                <td><input type="number" class="player-tb" value="${player.tb}" placeholder="e.g. 50" min="0"></td>
                <td><input type="number" class="player-so" value="${player.so}" placeholder="e.g. 20" min="0"></td>
                <td><button class="delete-btn text-sm px-2 py-1">Delete</button></td>
            `;
            row.querySelector('.delete-btn').addEventListener('click', () => {
                deletePlayerRow(row);
            });

            // Add event listeners to save on change
            row.querySelectorAll('input').forEach(input => {
                input.addEventListener('change', updateAndSaveRoster);
                input.addEventListener('keyup', updateAndSaveRoster); // For more immediate saving
            });
        }

        function deletePlayerRow(rowElement) {
            const rowIndex = Array.from(rosterTableBody.rows).indexOf(rowElement);
            if (rowIndex > -1) {
                globalRoster.splice(rowIndex, 1);
                rosterTableBody.deleteRow(rowIndex);
                saveRosterToLocalStorage();
            }
        }
        
        function updateAndSaveRoster() {
            collectRosterData(); // Updates globalRoster from table inputs
            saveRosterToLocalStorage();
        }


        function collectRosterData() {
            globalRoster = [];
            const rows = rosterTableBody.rows;
            let allValid = true;
            for (let i = 0; i < rows.length; i++) {
                const nameInput = rows[i].querySelector('.player-name');
                const abInput = rows[i].querySelector('.player-ab');
                const hInput = rows[i].querySelector('.player-h');
                const tbInput = rows[i].querySelector('.player-tb');
                const soInput = rows[i].querySelector('.player-so');

                // Check if any input field is null (e.g., if a row was somehow malformed)
                if (!nameInput || !abInput || !hInput || !tbInput || !soInput) {
                    console.warn("Skipping malformed row in roster table.");
                    allValid = false; // Consider this an invalid state for the whole roster collection
                    continue;
                }

                const name = nameInput.value.trim();
                const ab = parseInt(abInput.value);
                const h = parseInt(hInput.value);
                const tb = parseInt(tbInput.value);
                const so = parseInt(soInput.value);

                if (name && !isNaN(ab) && !isNaN(h) && !isNaN(tb) && !isNaN(so)) {
                     if (ab < 0 || h < 0 || tb < 0 || so < 0) {
                        showMessage(`Player ${name || 'Unnamed'}: Stats must be non-negative.`);
                        allValid = false; continue;
                    }
                    if (h > ab) {
                        showMessage(`Player ${name || 'Unnamed'}: Hits (H) cannot exceed At-Bats (AB).`);
                        allValid = false; continue;
                    }
                    if (tb < h) { // Each hit is at least 1 base
                        showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be at least Hits (H).`);
                         allValid = false; continue;
                    }
                     if (so > ab) {
                        showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) cannot exceed At-Bats (AB).`);
                        allValid = false; continue;
                    }
                    if ( (h + so) > ab ) { 
                        if (so > (ab - h)) { // This is the more direct check
                             showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) plus Hits (H) cannot exceed At-Bats (AB). Please ensure SO <= AB - H.`);
                             allValid = false; continue;
                        }
                    }
                    globalRoster.push({ name, ab, h, tb, so });
                } else if (name || abInput.value || hInput.value || tbInput.value || soInput.value) {
                    // If any field has a value, but not all numeric fields are valid numbers,
                    // or if the name is present but numbers are missing/invalid.
                    // This indicates an incomplete or invalidly filled row.
                    if (name && (isNaN(ab) || isNaN(h) || isNaN(tb) || isNaN(so))) {
                         showMessage(`Player ${name}: Please ensure all stat fields (AB, H, TB, SO) are filled with valid numbers.`);
                         allValid = false;
                    } else if (!name && (abInput.value || hInput.value || tbInput.value || soInput.value)) {
                         showMessage(`An unnamed player has stats entered. Please provide a name or clear the stats for that row.`);
                         allValid = false;
                    }
                    // We don't add partially filled rows to globalRoster
                }
            }
            return allValid;
        }
        
        function renderRosterFromGlobal() {
            rosterTableBody.innerHTML = ''; // Clear existing rows
            globalRoster.forEach(player => addPlayerRow(player));
        }

        function saveRosterToLocalStorage() {
            localStorage.setItem('littleLeagueRoster', JSON.stringify(globalRoster));
        }

        function loadRosterFromLocalStorage() {
            const savedRoster = localStorage.getItem('littleLeagueRoster');
            if (savedRoster) {
                try {
                    const parsedRoster = JSON.parse(savedRoster);
                    if (Array.isArray(parsedRoster)) {
                        globalRoster = parsedRoster;
                         // Validate loaded roster data structure here if necessary
                        globalRoster = globalRoster.filter(p => 
                            typeof p.name === 'string' &&
                            typeof p.ab === 'number' &&
                            typeof p.h === 'number' &&
                            typeof p.tb === 'number' &&
                            typeof p.so === 'number'
                        );
                    } else {
                        globalRoster = []; // Reset if format is incorrect
                    }
                } catch (e) {
                    console.error("Error parsing roster from local storage:", e);
                    globalRoster = []; // Reset on error
                }
                renderRosterFromGlobal();
            }
            if (globalRoster.length === 0) { // If no valid roster loaded or was empty
                addPlayerRow(); // Add one empty row
            }
        }

        function loadRosterFromURL() {
            const params = new URLSearchParams(window.location.search);
            const rosterData = params.get('roster');
            if (rosterData) {
                try {
                    const decodedRoster = JSON.parse(atob(rosterData));
                    if (Array.isArray(decodedRoster)) {
                         // Basic validation of URL data
                        const validatedRoster = decodedRoster.filter(p => 
                            typeof p.name === 'string' &&
                            typeof p.ab === 'number' && p.ab >= 0 &&
                            typeof p.h === 'number' && p.h >= 0 && p.h <= p.ab &&
                            typeof p.tb === 'number' && p.tb >= p.h &&
                            typeof p.so === 'number' && p.so >= 0 && (p.so + p.h) <= p.ab
                        );

                        if (validatedRoster.length !== decodedRoster.length) {
                            showMessage("Some player data from the URL was invalid and has been omitted.");
                        }

                        if (validatedRoster.length > 0) {
                            globalRoster = validatedRoster;
                            renderRosterFromGlobal();
                            saveRosterToLocalStorage(); // Save valid URL roster to local storage
                            showMessage("Roster loaded from URL!");
                             // Clean the URL
                            window.history.replaceState({}, document.title, window.location.pathname);
                            return; // Exit after successfully loading from URL
                        } else if (decodedRoster.length > 0) {
                             showMessage("Roster data in URL was invalid. Loading from local storage instead.");
                        }
                    } else {
                         showMessage("Invalid roster format in URL. Loading from local storage instead.");
                    }
                } catch (e) {
                    console.error("Error parsing roster data from URL:", e);
                    showMessage("Could not load roster from URL: Corrupted data. Loading from local storage.");
                }
                 // Clean the URL if attempted load failed or was partial
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            // Fallback to local storage if no URL param or if URL loading failed
            loadRosterFromLocalStorage();
        }
        
        generateShareUrlBtn.addEventListener('click', () => {
            if (!collectRosterData() || globalRoster.length === 0) { // collectRosterData now returns validity
                 showMessage("Please enter complete and valid player data before generating a URL.");
                 return;
            }
            const jsonRoster = JSON.stringify(globalRoster);
            const base64Roster = btoa(jsonRoster); // Base64 encode
            const url = `${window.location.origin}${window.location.pathname}?roster=${base64Roster}`;
            shareUrlInput.value = url;
        });

        copyUrlBtn.addEventListener('click', () => {
            if (shareUrlInput.value) {
                shareUrlInput.select();
                try {
                    document.execCommand('copy'); // Deprecated but widely supported
                    showMessage("URL copied to clipboard!");
                } catch (err) {
                    // Fallback for browsers that don't support execCommand or if it fails
                    navigator.clipboard.writeText(shareUrlInput.value).then(() => {
                        showMessage("URL copied to clipboard!");
                    }).catch(e => {
                        showMessage("Failed to copy URL. Please copy it manually.");
                        console.error("Copy failed: ", e);
                    });
                }
            } else {
                showMessage("Generate a URL first.");
            }
        });

        // --- Probability Calculation ---
        function calculatePlayerProbs(player) {
            if (!player || typeof player.ab !== 'number' || player.ab === 0) {
                // Return a default structure for a player who never bats or has invalid AB
                return { ...player, name: player.name || "Unknown Player", P_SO: 0, P_Out_Other: 1, P_1B: 0, P_2B: 0, P_HR: 0, C_SO: 0, C_Out_Other: 1, C_1B: 1, C_2B: 1, C_HR: 1 };
            }

            let { ab, h, tb, so } = player;
            // Ensure they are numbers, default to 0 if somehow not (should be caught by collectRosterData)
            ab = Number(ab) || 0; 
            h = Number(h) || 0;
            tb = Number(tb) || 0;
            so = Number(so) || 0;

            // Basic validation, though collectRosterData should prevent most issues
            if (ab === 0) return { ...player, P_SO: 0, P_Out_Other: 1, P_1B: 0, P_2B: 0, P_HR: 0, C_SO: 0, C_Out_Other: 1, C_1B: 1, C_2B: 1, C_HR: 1 };
            h = Math.min(h, ab);
            so = Math.min(so, ab - h); // SO cannot be more than ABs that weren't hits
            tb = Math.max(tb, h); // TB must be at least H

            const avg = h / ab;
            const slg = tb / ab;
            let iso = slg - avg;
            if (iso < 0) iso = 0; // ISO cannot be negative

            let p_hr = 0, p_2b = 0, p_1b = 0;

            if (avg > 0) { // Only calculate hit types if there are hits
                // Simplified model for XBH distribution from ISO
                // Assume HRs are roughly 1/3 of ISO power, 2B are 2/3 (very rough)
                // More advanced: use league averages or regression. For Little League, this is a guess.
                // P(HR) = ISO / 4 (since HR adds 3 extra bases over a single)
                // P(2B) = ISO / 2 (since 2B adds 1 extra base over a single) - this is too simple.

                // Let's use a slightly more common approach:
                // Assume fixed ratios of XBH for simplicity in little league context
                // For example, of the "extra base hits", 20% are HR, 80% are 2B (no triples)
                // This is a placeholder logic and can be much improved.
                const xbh_rate = iso; // Rate of "extra bases per AB"
                
                // A common simple model:
                // P(HR) = some_factor_HR * ISO
                // P(2B) = some_factor_2B * ISO
                // P(1B) = AVG - P(HR) - P(2B)
                // For this, let's try to derive from TB = 1*P(1B) + 2*P(2B) + 4*P(HR)
                // and H = P(1B) + P(2B) + P(HR)
                // This becomes complex to solve directly without more assumptions.

                // Simpler: allocate ISO to HR and 2B.
                // Assume a ratio for how ISO splits into HRs and 2Bs.
                // e.g., for every HR, there are 'alpha' doubles.
                // ISO = P(1B)*0 + P(2B)*1 + P(3B)*2 + P(HR)*3  (extra bases over single)
                // AVG = P(1B) + P(2B) + P(3B) + P(HR)
                // SLG = P(1B)*1 + P(2B)*2 + P(3B)*3 + P(HR)*4
                // SLG - AVG = P(2B)*1 + P(3B)*2 + P(HR)*3  (This is ISO)
                // Let's omit triples for this league. ISO = P(2B) + 3*P(HR)

                const alpha_hr_vs_2b_bases = 3.0; // HR gives ~3 more "extra bases" than a 2B, relative to a single.
                                                // Or, a HR is "worth" 3 2Bs in terms of ISO contribution if P(2B) was main driver.
                                                // This is not standard, just a way to split ISO.
                // A common heuristic:
                p_hr = iso / (alpha_hr_vs_2b_bases + 1.0); // Crude split of ISO, assuming HRs are less frequent than 2Bs for the same ISO points
                p_2b = iso - 3 * p_hr; // Remaining ISO points go to doubles (1 ISO point per double)
                
                if (p_2b < 0) { // If calculated p_hr was too high for the ISO
                    p_hr = iso / 3.0; // All ISO from HRs
                    p_2b = 0;
                }

                // Cap XBH probabilities by AVG
                if (p_hr + p_2b > avg) {
                    const total_xbh_prob_raw = p_hr + p_2b;
                    if (total_xbh_prob_raw > 0) {
                        p_hr = (p_hr / total_xbh_prob_raw) * avg * 0.8; // Give some room for singles
                        p_2b = (p_2b / total_xbh_prob_raw) * avg * 0.8;
                    } else {
                        p_hr = 0; p_2b = 0;
                    }
                }
                
                p_1b = avg - p_hr - p_2b;

                // Ensure non-negativity and that sum is AVG
                p_hr = Math.max(0, p_hr);
                p_2b = Math.max(0, p_2b);
                p_1b = Math.max(0, avg - p_hr - p_2b);

                // Normalize hit probabilities to sum exactly to avg
                const current_sum_hit_probs = p_1b + p_2b + p_hr;
                if (current_sum_hit_probs > 0 && avg > 0) {
                    const scale = avg / current_sum_hit_probs;
                    p_1b *= scale;
                    p_2b *= scale;
                    p_hr *= scale;
                } else if (avg > 0) { // If all calculations led to zero hit type probs but avg is positive
                    p_1b = avg; // All hits are singles
                    p_2b = 0;
                    p_hr = 0;
                }
            }
            
            let p_so = so / ab;
            let p_other_out = (ab - h - so) / ab;

            // Ensure non-negative probabilities for outs
            p_so = Math.max(0, p_so);
            p_other_out = Math.max(0, p_other_out);
            if (p_so + p_other_out + avg > 1.0000001) { // If sum exceeds 1 due to previous calcs/rounding
                 // Prioritize AVG and P_SO, adjust P_Other_Out
                 p_other_out = 1.0 - avg - p_so;
                 p_other_out = Math.max(0, p_other_out); // Ensure it's not negative
                 // If still > 1, it means P_SO + AVG > 1, which implies SO > AB-H.
                 // This should have been caught by collectRosterData or the initial SO clamp.
                 // If it still occurs, clamp P_SO.
                 if (avg + p_so > 1.0) {
                     p_so = 1.0 - avg;
                     p_so = Math.max(0, p_so);
                     p_other_out = 0;
                 }
            }


            // Final normalization to ensure all probabilities sum to 1.0
            let all_probs = [p_1b, p_2b, p_hr, p_so, p_other_out];
            let sum_all_probs = all_probs.reduce((s, p) => s + p, 0);

            if (Math.abs(sum_all_probs - 1.0) > 1e-9) { // If not close to 1
                if (sum_all_probs > 0) {
                    const scaleFactor = 1.0 / sum_all_probs;
                    p_1b *= scaleFactor;
                    p_2b *= scaleFactor;
                    p_hr *= scaleFactor;
                    p_so *= scaleFactor;
                    p_other_out *= scaleFactor;
                } else if (ab > 0) { // All probabilities are zero, but there were ABs
                    p_other_out = 1.0; // Default to an out
                } else { // ab === 0, already handled, but as a safeguard
                    p_other_out = 1.0;
                }
            }
            
            // Recalculate sum for cumulative probabilities after any normalization
            sum_all_probs = p_1b + p_2b + p_hr + p_so + p_other_out;
            // Ensure the sum is exactly 1 for cumulative distribution, typically by adjusting the largest component (often p_other_out or p_1b)
            // For simplicity, if there's a tiny remainder, add to p_other_out or subtract if sum > 1
            if (sum_all_probs !== 1.0) {
                p_other_out += (1.0 - sum_all_probs);
            }


            return {
                ...player, // Original player data
                P_SO: p_so, P_Out_Other: p_other_out, P_1B: p_1b, P_2B: p_2b, P_HR: p_hr,
                // Cumulative probabilities for outcome generation
                C_SO: p_so,
                C_Out_Other: p_so + p_other_out,
                C_1B: p_so + p_other_out + p_1b,
                C_2B: p_so + p_other_out + p_1b + p_2b,
                C_HR: 1.0 // Sum of all (should be 1.0 after normalization)
            };
        }


        // --- Game Simulation Logic ---
        function getPAOutcome(playerProbs) {
            const r = Math.random();
            if (r < playerProbs.C_SO) return "SO";
            if (r < playerProbs.C_Out_Other) return "OutOther";
            if (r < playerProbs.C_1B) return "1B";
            if (r < playerProbs.C_2B) return "2B";
            return "HR"; // Remainder is HR
        }

        function simulateGame(lineupWithProbs) {
            if (!lineupWithProbs || lineupWithProbs.length === 0) return 0;

            let totalGameRuns = 0;
            let currentBatterIdx = 0;

            for (let inning = 0; inning < NUM_INNINGS; inning++) {
                let outs = 0;
                let inningRuns = 0;
                let bases = [0, 0, 0]; // 0:1st, 1:2nd, 2:3rd. Value 1 if occupied, 0 if not.

                while (outs < 3 && inningRuns < MAX_RUNS_PER_INNING) {
                    if (lineupWithProbs.length === 0) break; // Should not happen if validated before
                    const batterProbs = lineupWithProbs[currentBatterIdx % lineupWithProbs.length];
                    const outcome = getPAOutcome(batterProbs);
                    let runsThisPA = 0;

                    if (outcome === "SO" || outcome === "OutOther") {
                        outs++;
                    } else { // Hit
                        if (outcome === "HR") {
                            runsThisPA++; // Batter scores
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } // Runner on 3rd scores
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } // Runner on 2nd scores
                            if (bases[0]) { runsThisPA++; bases[0] = 0; } // Runner on 1st scores
                        } else if (outcome === "2B") {
                            // Runners advance 2 bases
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } // Runner on 3rd scores
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } // Runner on 2nd scores
                            if (bases[0]) { bases[2] = 1; bases[0] = 0; } // Runner on 1st to 3rd
                            bases[1] = 1; // Batter to 2nd
                        } else if (outcome === "1B") {
                            // Runners advance 1 base (with force)
                            if (bases[2] && bases[1] && bases[0]) { // Bases loaded
                                runsThisPA++; // Runner from 3rd scores
                                // bases[2] remains 1 (runner from 2nd)
                                // bases[1] remains 1 (runner from 1st)
                                // bases[0] remains 1 (batter)
                            } else {
                                if (bases[2]) { runsThisPA++; bases[2] = 0; } // Runner on 3rd scores
                                if (bases[1]) { bases[2] = 1; bases[1] = 0; } // Runner on 2nd to 3rd
                                if (bases[0]) { bases[1] = 1; bases[0] = 0; } // Runner on 1st to 2nd
                                bases[0] = 1; // Batter to 1st
                            }
                        }
                    }
                    
                    inningRuns += runsThisPA;
                    if (inningRuns >= MAX_RUNS_PER_INNING) {
                        inningRuns = MAX_RUNS_PER_INNING; // Cap at 5
                        totalGameRuns += inningRuns;
                        currentBatterIdx = (currentBatterIdx + 1); // No modulo here, do it before next PA
                        break; // Inning ends immediately due to run cap
                    }
                    currentBatterIdx = (currentBatterIdx + 1); // No modulo here, do it before next PA
                } // End of PAs for the inning (outs or run cap)
                
                if (inningRuns < MAX_RUNS_PER_INNING) { // if inning didn't end due to run limit
                     totalGameRuns += inningRuns;
                }
            } // End of innings
            return totalGameRuns;
        }
        
        async function runManySimulations(lineup, numSims) {
            // This function is async only to match the pattern if we later add true async behavior (e.g., workers)
            // Currently, it's a blocking loop.
            return new Promise(resolve => {
                let totalRunsAcrossSims = 0;
                const processedLineup = lineup.map(p => calculatePlayerProbs(p));
                
                // Check if any player in the processed lineup is invalid (e.g. calculatePlayerProbs returned undefined or a basic object)
                if (processedLineup.some(p => !p || typeof p.P_SO === 'undefined')) {
                    console.error("Invalid player data found in lineup during simulation batch:", processedLineup.filter(p => !p || typeof p.P_SO === 'undefined'));
                    showMessage("Error: Invalid player data detected. Cannot run simulations.");
                    resolve(0); // Resolve with 0 or an error indicator
                    return;
                }


                for (let i = 0; i < numSims; i++) {
                    totalRunsAcrossSims += simulateGame(processedLineup);
                }
                resolve(totalRunsAcrossSims / numSims);
            });
        }


        runSimulationBtn.addEventListener('click', async () => {
            if (!collectRosterData() || globalRoster.length === 0) {
                showMessage("Please add players to the roster with complete and valid stats first.");
                return;
            }
            
            loadingIndicator.style.display = 'block';
            simulationResultsDiv.classList.add('hidden'); // Hide old results
            runSimulationBtn.disabled = true;
            optimizeLineupBtn.disabled = true; // Disable optimize button too

            // Use setTimeout to allow UI to update (show loading) before heavy computation
            await new Promise(resolve => setTimeout(resolve, 50));


            const processedRoster = globalRoster.map(p => calculatePlayerProbs(p));
            if (processedRoster.some(p => !p || typeof p.P_SO === 'undefined')) { // Check for valid probability objects
                 showMessage("Error processing player data. Please check inputs for all players.");
                 loadingIndicator.style.display = 'none';
                 runSimulationBtn.disabled = false;
                 optimizeLineupBtn.disabled = false;
                 return;
            }


            const numSimulations = 100000;
            const runCounts = {}; // Using an object as a frequency map
            const maxPossibleRuns = NUM_INNINGS * MAX_RUNS_PER_INNING; 

            // Batch simulations to prevent freezing for too long, and update UI periodically
            const batchSize = 5000;
            let simsDone = 0;

            function simulateBatch() {
                for (let i = 0; i < batchSize && simsDone < numSimulations; i++) {
                    const runs = simulateGame(processedRoster);
                    runCounts[runs] = (runCounts[runs] || 0) + 1;
                    simsDone++;
                }

                if (simsDone < numSimulations) {
                    loadingIndicator.textContent = `Simulating... ${((simsDone / numSimulations) * 100).toFixed(0)}% complete.`;
                    setTimeout(simulateBatch, 0); // Yield to event loop
                } else {
                    // All simulations complete
                    loadingIndicator.textContent = 'Simulating... Please wait. This might take a moment.'; // Reset text
                    loadingIndicator.style.display = 'none';

                    // Prepare data for chart and table
                    const labels = [];
                    const data = [];
                    runPercentagesTableBody.innerHTML = ''; // Clear previous results

                    // Determine a reasonable max for the x-axis of the chart
                    let practicalMaxRuns = 0;
                    for (const runs in runCounts) {
                        if (runCounts[runs] > 0) {
                            practicalMaxRuns = Math.max(practicalMaxRuns, parseInt(runs));
                        }
                    }
                    // Ensure we show at least up to a certain number of runs (e.g., 15 or 20) or the max observed.
                    const displayMaxRuns = Math.max(15, practicalMaxRuns);


                    for (let i = 0; i <= displayMaxRuns; i++) {
                        const count = runCounts[i] || 0;
                        labels.push(i.toString());
                        data.push(count);
                        if (count > 0 || i <= displayMaxRuns) { // Show if count > 0 or within typical range
                             const percentage = ((count / numSimulations) * 100).toFixed(2);
                             const row = runPercentagesTableBody.insertRow();
                             row.innerHTML = `<td>${i}</td><td>${count}</td><td>${percentage}%</td>`;
                        }
                    }
                    
                    if (runsChart) {
                        runsChart.destroy();
                    }
                    runsChart = new Chart(runsHistogramChartCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Frequency of Runs Scored',
                                data: data,
                                backgroundColor: 'rgba(59, 130, 246, 0.7)', 
                                borderColor: 'rgba(59, 130, 246, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            scales: { 
                                y: { beginAtZero: true, title: { display: true, text: 'Number of Games' } },
                                x: { title: { display: true, text: 'Runs Scored in a Game' } } 
                            },
                            responsive: true,
                            maintainAspectRatio: false // Crucial for fitting into the styled container
                        }
                    });

                    simulationResultsDiv.classList.remove('hidden');
                    runSimulationBtn.disabled = false;
                    optimizeLineupBtn.disabled = false;
                }
            }
            simulateBatch(); // Start the first batch
        });

        // --- Lineup Optimization ---
        function getAllPermutations(arr) { 
            if (arr.length === 0) return [[]];
            if (arr.length === 1) return [[...arr]]; // Return copy

            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const current = arr[i];
                const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
                const remainingPermuted = getAllPermutations(remaining);
                for (let j = 0; j < remainingPermuted.length; j++) {
                    result.push([current, ...remainingPermuted[j]]);
                }
            }
            return result;
        }
        
        optimizeLineupBtn.addEventListener('click', async () => {
            if (!collectRosterData() || globalRoster.length === 0) {
                showMessage("Please add players to the roster with complete and valid stats first.");
                return;
            }
            if (globalRoster.length < 1) { // Should be caught by length === 0, but good check
                showMessage("Optimization requires at least one player.");
                return;
            }

            const numPlayers = globalRoster.length;
            const simsPerLineup = parseInt(optimizationSimsSelect.value);

            if (numPlayers > MAX_BRUTE_FORCE_OPTIMIZATION_SIZE && numPlayers * numPlayers * simsPerLineup > 2000000) { // Heuristic for long calc
                 if (!confirm(`Optimizing a roster of ${numPlayers} players with ${simsPerLineup} simulations per lineup might take a very long time (potentially minutes). Continue?`)) {
                    return;
                }
            }


            optimizationLoadingIndicator.style.display = 'block';
            optimizationResultDiv.classList.add('hidden');
            optimizeLineupBtn.disabled = true;
            runSimulationBtn.disabled = true; // Disable simulation button too
            
            await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI update

            let bestLineup = [];
            let bestExpectedRuns = -1;

            const playersToOptimize = globalRoster.map(p => ({...p})); // Deep copy for safety if objects were complex

            if (playersToOptimize.length === 0) { // Should be caught earlier
                 showMessage("No players to optimize.");
                 optimizationLoadingIndicator.style.display = 'none';
                 optimizeLineupBtn.disabled = false;
                 runSimulationBtn.disabled = false;
                 return;
            }
            
            if (playersToOptimize.length === 1) {
                bestLineup = playersToOptimize; // Already a copy
                bestExpectedRuns = await runManySimulations(bestLineup, simsPerLineup);
            } else if (playersToOptimize.length <= MAX_BRUTE_FORCE_OPTIMIZATION_SIZE) {
                optimizationLoadingIndicator.textContent = `Optimizing (brute force, ${getAllPermutations(playersToOptimize).length} permutations)... This may take time.`;
                const permutations = getAllPermutations(playersToOptimize);
                let processedCount = 0;
                for (const perm of permutations) {
                    const avgRuns = await runManySimulations(perm, simsPerLineup);
                    if (avgRuns > bestExpectedRuns) {
                        bestExpectedRuns = avgRuns;
                        bestLineup = perm; // perm is already a new array from getAllPermutations
                    }
                    processedCount++;
                    if (processedCount % 10 === 0 || processedCount === permutations.length) { // Update UI periodically
                         optimizationLoadingIndicator.textContent = `Optimizing (brute force)... ${((processedCount/permutations.length)*100).toFixed(0)}%`;
                         await new Promise(resolve => setTimeout(resolve, 0)); // Yield
                    }
                }
            } else {
                // Heuristic: Stochastic Hill Climbing for larger rosters
                optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... This may take time.`;
                let currentLineup = [...playersToOptimize]; 
                // Shuffle for a random start
                for (let i = currentLineup.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentLineup[i], currentLineup[j]] = [currentLineup[j], currentLineup[i]];
                }

                bestLineup = [...currentLineup];
                bestExpectedRuns = await runManySimulations(currentLineup, simsPerLineup);

                // Iterations: e.g., N^2 for N players, or a fixed large number.
                // More iterations = more thorough search but slower.
                const iterations = Math.min(1500, numPlayers * numPlayers * 3); 
                let noImprovementStreak = 0;
                const maxNoImprovementStreak = Math.max(50, numPlayers * 5); // Stop if no improvement for a while

                for (let i = 0; i < iterations; i++) {
                    let tempLineup = [...bestLineup]; 
                    const idx1 = Math.floor(Math.random() * tempLineup.length);
                    let idx2 = Math.floor(Math.random() * tempLineup.length);
                    while (idx1 === idx2 && tempLineup.length > 1) { 
                        idx2 = Math.floor(Math.random() * tempLineup.length);
                    }
                    [tempLineup[idx1], tempLineup[idx2]] = [tempLineup[idx2], tempLineup[idx1]]; // Swap
                    
                    const tempAvgRuns = await runManySimulations(tempLineup, simsPerLineup);
                    if (tempAvgRuns > bestExpectedRuns) {
                        bestExpectedRuns = tempAvgRuns;
                        bestLineup = [...tempLineup];
                        noImprovementStreak = 0; // Reset streak
                    } else {
                        noImprovementStreak++;
                    }

                    if (i % 20 === 0 || i === iterations -1) { // Update UI periodically
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Iteration ${i+1}/${iterations}`;
                        await new Promise(resolve => setTimeout(resolve, 0)); // Yield
                    }
                    if (noImprovementStreak > maxNoImprovementStreak) {
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Converged after ${i+1} iterations.`;
                        await new Promise(resolve => setTimeout(resolve, 0)); // Yield
                        break; 
                    }
                }
            }

            optimizedLineupList.innerHTML = '';
            if (bestLineup && bestLineup.length > 0) {
                bestLineup.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = player.name || "Unnamed Player"; // Handle if name was missing
                    optimizedLineupList.appendChild(li);
                });
                expectedRunsValue.textContent = bestExpectedRuns.toFixed(3);
            } else {
                 expectedRunsValue.textContent = "N/A";
                 optimizedLineupList.innerHTML = '<li>No valid lineup found.</li>';
            }
            
            optimizationResultDiv.classList.remove('hidden');
            optimizationLoadingIndicator.style.display = 'none';
            optimizationLoadingIndicator.textContent = 'Optimizing... This could take some time.'; // Reset text
            optimizeLineupBtn.disabled = false;
            runSimulationBtn.disabled = false;
        });


        // --- Initialization ---
        addPlayerBtn.addEventListener('click', () => {
            addPlayerRow();
            // After adding a row, it's good to save, though individual inputs also save.
            // This ensures an empty added row gets into the globalRoster if user navigates away.
            updateAndSaveRoster(); 
        });
        
        // Load data on page start
        document.addEventListener('DOMContentLoaded', () => {
            // Corrected the value for 2000 simulations in the select dropdown
            const opt2000 = optimizationSimsSelect.querySelector('option[value_2000]');
            if (opt2000) opt2000.value = "2000";

            loadRosterFromURL(); 
        });

    </script>
</body>
</html>
