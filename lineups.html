<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little League Stat Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937; /* Dark gray */
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb; /* Light gray border */
            padding-bottom: 0.5rem;
        }
        label {
            font-weight: 500;
            color: #374151; /* Medium gray */
        }
        input[type="text"], input[type="number"], select {
            border: 1px solid #d1d5db; /* Gray border */
            border-radius: 4px;
            padding: 8px 12px;
            width: 100%;
            margin-top: 4px;
            box-sizing: border-box;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none; /* Safari and Chrome */
            margin: 0;
        }
        button {
            background-color: #3b82f6; /* Blue */
            color: white;
            font-weight: 500;
            padding: 10px 15px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #2563eb; /* Darker blue */
        }
        button:disabled {
            background-color: #9ca3af; /* Gray for disabled */
            cursor: not-allowed;
        }
        .delete-btn {
            background-color: #ef4444; /* Red */
        }
        .delete-btn:hover {
            background-color: #dc2626; /* Darker red */
        }
        .move-btn {
            background-color: #6b7280; /* Gray */
            padding: 4px 8px;
            font-size: 0.8rem;
            margin: 0 2px;
        }
        .move-btn:hover {
            background-color: #4b5563; /* Darker Gray */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            border: 1px solid #e5e7eb; /* Light gray border */
            padding: 10px;
            text-align: left;
            font-size: 0.9rem;
            vertical-align: middle; /* Align content vertically */
        }
        th {
            background-color: #f9fafb; /* Very light gray */
            font-weight: 600;
        }
        .stats-table td {
            text-align: center;
        }
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000; /* Ensure it's on top */
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 90%; /* For smaller screens */
        }
        #loadingIndicator, #optimizationLoadingIndicator { /* Combined for brevity */
            display: none; /* Hidden by default */
            margin-top: 1rem;
            font-weight: 500;
            color: #1d4ed8; /* Darker blue for text */
        }
        .chart-container {
            position: relative;
            height: 350px; 
            width: 100%;   
            margin-bottom: 1rem; 
        }
        .order-buttons button {
            min-width: 30px; /* Ensure buttons have some width */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Little League Stat Simulator</h1>

        <div class="card">
            <h2>Roster Input</h2>
            <p class="text-sm text-gray-600 mb-3">Enter your players below. The lineup order can be adjusted using the ▲/▼ buttons. Data is saved automatically.</p>
            <table id="rosterTable">
                <thead>
                    <tr>
                        <th>Player Name</th>
                        <th>At-Bats (AB)</th>
                        <th>Hits (H)</th>
                        <th>Total Bases (TB)</th>
                        <th>Strikeouts (SO)</th>
                        <th class="w-24 text-center">Order</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="rosterTableBody">
                </tbody>
            </table>
            <button id="addPlayerBtn" class="mt-4">Add Player</button>
        </div>

        <div class="card">
            <h2>Game Simulation</h2>
            <div class="mb-4">
                <label for="numSimulationsSelect" class="block mb-1">Number of Simulations:</label>
                <select id="numSimulationsSelect">
                    <option value="10000">10,000</option>
                    <option value="50000">50,000</option>
                    <option value="100000" selected>100,000 (Default)</option>
                    <option value="250000">250,000</option>
                    <option value="500000">500,000 (Slower)</option>
                </select>
            </div>
            <button id="runSimulationBtn">Run Simulation</button>
            <div id="loadingIndicator">Simulating... Please wait. This might take a moment.</div>
            <div id="simulationResults" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-2">Run Distribution Histogram</h3>
                <div class="chart-container">
                    <canvas id="runsHistogramChart"></canvas>
                </div>
                <p class="mt-4 text-lg font-semibold">Expected Runs per Game: <span id="expectedRunsPerGameValue" class="text-blue-700"></span></p>
                <h3 class="text-xl font-semibold mt-6 mb-2">Run Percentages</h3>
                <table id="runPercentagesTable" class="stats-table">
                    <thead><tr><th>Runs Scored</th><th>Frequency</th><th>Percentage</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div class="card">
            <h2>Lineup Optimization</h2>
            <div>
                <label for="optimizationSimsSelect" class="block mb-1">Simulations per Lineup:</label>
                <select id="optimizationSimsSelect">
                    <option value="100">100 (Fastest)</option>
                    <option value="500">500</option>
                    <option value="1000" selected>1000 (Recommended)</option>
                    <option value="2000">2000</option> 
                    <option value="5000">5000 (Most Accurate)</option>
                </select>
            </div>
            <button id="optimizeLineupBtn" class="mt-4">Optimize Lineup</button>
            <div id="optimizationLoadingIndicator" class="hidden mt-2 font-medium text-blue-600">Optimizing... This could take some time.</div>
            <div id="optimizationResult" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-1">Optimized Lineup:</h3>
                <ol id="optimizedLineupList" class="list-decimal list-inside pl-2 bg-gray-50 p-3 rounded"></ol>
                <p class="mt-2 font-semibold">Expected Runs: <span id="expectedRunsValue" class="text-blue-700"></span></p>
            </div>
        </div>

        <div class="card">
            <h2>Share Roster</h2>
            <button id="generateShareUrlBtn">Generate Shareable URL</button>
            <div class="mt-2 flex items-center space-x-2">
                <input type="text" id="shareUrlInput" readonly class="bg-gray-100 flex-grow">
                <button id="copyUrlBtn">Copy URL</button>
            </div>
        </div>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <p id="modalMessageText"></p>
            <button id="closeModalBtn" class="mt-4">Close</button>
        </div>
    </div>

    <script>
        // --- Global State & Constants ---
        let globalRoster = [];
        let runsChart = null;
        const MAX_RUNS_PER_INNING = 5;
        const NUM_INNINGS = 6;
        const MAX_BRUTE_FORCE_OPTIMIZATION_SIZE = 8;

        // --- DOM Elements ---
        const rosterTableBody = document.getElementById('rosterTableBody');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const numSimulationsSelect = document.getElementById('numSimulationsSelect'); // New select for num simulations
        const runSimulationBtn = document.getElementById('runSimulationBtn');
        const simulationResultsDiv = document.getElementById('simulationResults');
        const runsHistogramChartCtx = document.getElementById('runsHistogramChart').getContext('2d');
        const expectedRunsPerGameValue = document.getElementById('expectedRunsPerGameValue'); // For displaying expected runs
        const runPercentagesTableBody = document.getElementById('runPercentagesTable').querySelector('tbody');
        const optimizationSimsSelect = document.getElementById('optimizationSimsSelect');
        const optimizeLineupBtn = document.getElementById('optimizeLineupBtn');
        const optimizationResultDiv = document.getElementById('optimizationResult');
        const optimizedLineupList = document.getElementById('optimizedLineupList');
        const expectedRunsValue = document.getElementById('expectedRunsValue');
        const generateShareUrlBtn = document.getElementById('generateShareUrlBtn');
        const shareUrlInput = document.getElementById('shareUrlInput');
        const copyUrlBtn = document.getElementById('copyUrlBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const optimizationLoadingIndicator = document.getElementById('optimizationLoadingIndicator');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const closeModalBtn = document.getElementById('closeModalBtn');

        // --- Utility Functions ---
        function showMessage(message) {
            modalMessageText.textContent = message;
            messageModal.classList.remove('hidden');
        }
        function hideMessage() {
            messageModal.classList.add('hidden');
        }
        closeModalBtn.addEventListener('click', hideMessage);

        // --- Roster Management ---
        function addPlayerRow(player = { name: '', ab: '', h: '', tb: '', so: '' }, index = -1) {
            const row = rosterTableBody.insertRow(index); 
            const name = player.name || '';
            const ab = player.ab === undefined || player.ab === null ? '' : player.ab;
            const h = player.h === undefined || player.h === null ? '' : player.h;
            const tb = player.tb === undefined || player.tb === null ? '' : player.tb;
            const so = player.so === undefined || player.so === null ? '' : player.so;

            row.innerHTML = `
                <td><input type="text" class="player-name" value="${name}" placeholder="Player Name"></td>
                <td><input type="number" class="player-ab" value="${ab}" placeholder="e.g. 100" min="0"></td>
                <td><input type="number" class="player-h" value="${h}" placeholder="e.g. 30" min="0"></td>
                <td><input type="number" class="player-tb" value="${tb}" placeholder="e.g. 50" min="0"></td>
                <td><input type="number" class="player-so" value="${so}" placeholder="e.g. 20" min="0"></td>
                <td class="text-center order-buttons">
                    <button class="move-btn move-up-btn" title="Move Up">▲</button>
                    <button class="move-btn move-down-btn" title="Move Down">▼</button>
                </td>
                <td><button class="delete-btn text-sm px-2 py-1">Delete</button></td>
            `;
            
            const currentRowIndex = Array.from(rosterTableBody.rows).indexOf(row);

            row.querySelector('.move-up-btn').addEventListener('click', () => movePlayer(currentRowIndex, -1));
            row.querySelector('.move-down-btn').addEventListener('click', () => movePlayer(currentRowIndex, 1));
            
            row.querySelector('.delete-btn').addEventListener('click', () => {
                deletePlayerRow(row);
            });

            row.querySelectorAll('input').forEach(input => {
                input.addEventListener('change', () => {
                    validateRowOnInputChange(row); 
                    readTableIntoGlobalRoster(); 
                    saveRosterToLocalStorage(); 
                });
                input.addEventListener('keyup', () => {
                    readTableIntoGlobalRoster();
                    saveRosterToLocalStorage();
                });
            });
        }
        
        function validateRowOnInputChange(row) {
            const nameInput = row.querySelector('.player-name');
            const abInput = row.querySelector('.player-ab');
            const hInput = row.querySelector('.player-h');
            const tbInput = row.querySelector('.player-tb');
            const soInput = row.querySelector('.player-so');

            const name = nameInput.value.trim();
            const ab = abInput.value !== '' ? parseInt(abInput.value) : null;
            const h = hInput.value !== '' ? parseInt(hInput.value) : null;
            const tb = tbInput.value !== '' ? parseInt(tbInput.value) : null;
            const so = soInput.value !== '' ? parseInt(soInput.value) : null;
            
            let issueFound = false;

            if (ab !== null && ab < 0) { showMessage(`Player ${name || 'Unnamed'}: At-Bats (AB) must be non-negative.`); issueFound = true; abInput.focus();}
            if (h !== null && h < 0) { showMessage(`Player ${name || 'Unnamed'}: Hits (H) must be non-negative.`); issueFound = true; hInput.focus();}
            if (tb !== null && tb < 0) { showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be non-negative.`); issueFound = true; tbInput.focus();}
            if (so !== null && so < 0) { showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) must be non-negative.`); issueFound = true; soInput.focus();}

            if (!issueFound && ab !== null && h !== null && h > ab) {
                showMessage(`Player ${name || 'Unnamed'}: Hits (H) cannot exceed At-Bats (AB).`); hInput.focus(); issueFound = true;
            }
            if (!issueFound && h !== null && tb !== null && tb < h) {
                showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be at least Hits (H).`); tbInput.focus(); issueFound = true;
            }
            if (!issueFound && ab !== null && so !== null && so > ab) {
                showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) cannot exceed At-Bats (AB).`); soInput.focus(); issueFound = true;
            }
            if (!issueFound && ab !== null && h !== null && so !== null && (h + so) > ab) {
                 showMessage(`Player ${name || 'Unnamed'}: Hits (H) plus Strikeouts (SO) cannot exceed At-Bats (AB).`); soInput.focus(); issueFound = true;
            }
            return !issueFound; // Return true if no issues found for this specific row's direct values
        }

        function movePlayer(rowIndex, direction) {
            if (direction === -1 && rowIndex > 0) { 
                [globalRoster[rowIndex], globalRoster[rowIndex - 1]] = [globalRoster[rowIndex - 1], globalRoster[rowIndex]];
            } else if (direction === 1 && rowIndex < globalRoster.length - 1) { 
                [globalRoster[rowIndex], globalRoster[rowIndex + 1]] = [globalRoster[rowIndex + 1], globalRoster[rowIndex]];
            }
            renderRosterFromGlobal();
            saveRosterToLocalStorage();
        }

        function deletePlayerRow(rowElement) {
            const rowIndex = Array.from(rosterTableBody.rows).indexOf(rowElement);
            if (rowIndex > -1) {
                globalRoster.splice(rowIndex, 1); 
                renderRosterFromGlobal(); 
                saveRosterToLocalStorage();
            }
        }
        
        function readTableIntoGlobalRoster() {
            const newRoster = [];
            const rows = rosterTableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const name = rows[i].querySelector('.player-name').value.trim();
                const abStr = rows[i].querySelector('.player-ab').value;
                const hStr = rows[i].querySelector('.player-h').value;
                const tbStr = rows[i].querySelector('.player-tb').value;
                const soStr = rows[i].querySelector('.player-so').value;
                newRoster.push({
                    name: name,
                    ab: abStr === '' ? '' : parseInt(abStr), 
                    h:  hStr === '' ? '' : parseInt(hStr),
                    tb: tbStr === '' ? '' : parseInt(tbStr),
                    so: soStr === '' ? '' : parseInt(soStr),
                });
            }
            globalRoster = newRoster;
        }
        
        function renderRosterFromGlobal() {
            rosterTableBody.innerHTML = ''; 
            if (globalRoster.length === 0) { 
                addPlayerRow(); // Add one blank row if roster is empty
            } else {
                globalRoster.forEach((player, index) => {
                    addPlayerRow(player, index);
                });
            }
            updateMoveButtonStates();
        }

        function updateMoveButtonStates() {
            const rows = rosterTableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const upBtn = rows[i].querySelector('.move-up-btn');
                const downBtn = rows[i].querySelector('.move-down-btn');
                if (upBtn) upBtn.disabled = (i === 0);
                if (downBtn) downBtn.disabled = (i === rows.length - 1);
            }
        }

        function saveRosterToLocalStorage() {
            localStorage.setItem('littleLeagueRoster', JSON.stringify(globalRoster));
        }

        function loadRosterFromLocalStorage() {
            const savedRoster = localStorage.getItem('littleLeagueRoster');
            if (savedRoster) {
                try {
                    const parsedRoster = JSON.parse(savedRoster);
                    if (Array.isArray(parsedRoster)) {
                        globalRoster = parsedRoster.map(p => ({ 
                            name: p.name || '',
                            ab: p.ab === undefined || p.ab === null ? '' : p.ab,
                            h:  p.h  === undefined || p.h  === null ? '' : p.h,
                            tb: p.tb === undefined || p.tb === null ? '' : p.tb,
                            so: p.so === undefined || p.so === null ? '' : p.so,
                        }));
                    } else { globalRoster = []; }
                } catch (e) {
                    console.error("Error parsing roster from local storage:", e);
                    globalRoster = []; 
                }
            }
            renderRosterFromGlobal(); 
        }

        function validateRosterForProcessing() {
            readTableIntoGlobalRoster(); 
            if (globalRoster.length === 0) {
                showMessage("Roster is empty. Please add players first.");
                return false;
            }
            let firstErrorMessage = "";
            for (let i = 0; i < globalRoster.length; i++) {
                const player = globalRoster[i];
                const row = rosterTableBody.rows[i]; // Get corresponding row for focusing
                if (!player.name.trim()) {
                    firstErrorMessage = "One or more players is missing a name.";
                    if(row) row.querySelector('.player-name').focus();
                    break; 
                }
                const { name, ab, h, tb, so } = player;
                if (ab === '' || h === '' || tb === '' || so === '') {
                    firstErrorMessage = `Player ${name} has incomplete stats. All fields (AB, H, TB, SO) are required.`;
                    if(row) { // Focus the first empty field
                        if(ab === '') row.querySelector('.player-ab').focus();
                        else if(h === '') row.querySelector('.player-h').focus();
                        else if(tb === '') row.querySelector('.player-tb').focus();
                        else if(so === '') row.querySelector('.player-so').focus();
                    }
                    break;
                }
                if (isNaN(ab) || isNaN(h) || isNaN(tb) || isNaN(so)) {
                    firstErrorMessage = `Player ${name} has non-numeric stat entries.`;
                     if(row) { // Focus the first non-numeric field
                        if(isNaN(ab)) row.querySelector('.player-ab').focus();
                        else if(isNaN(h)) row.querySelector('.player-h').focus();
                        else if(isNaN(tb)) row.querySelector('.player-tb').focus();
                        else if(isNaN(so)) row.querySelector('.player-so').focus();
                    }
                    break;
                }
                // Use validateRowOnInputChange for individual value checks, but adapt for loop context
                if (ab < 0 || h < 0 || tb < 0 || so < 0) {
                     firstErrorMessage = `Player ${name}: Stats must be non-negative.`; if(row && ab < 0) row.querySelector('.player-ab').focus(); /* ... etc */ break;
                }
                if (h > ab) {
                    firstErrorMessage = `Player ${name}: Hits (H) cannot exceed At-Bats (AB).`; if(row) row.querySelector('.player-h').focus(); break;
                }
                if (tb < h) {
                    firstErrorMessage = `Player ${name}: Total Bases (TB) must be at least Hits (H).`; if(row) row.querySelector('.player-tb').focus(); break;
                }
                if (so > ab) {
                    firstErrorMessage = `Player ${name}: Strikeouts (SO) cannot exceed At-Bats (AB).`; if(row) row.querySelector('.player-so').focus(); break;
                }
                if ((h + so) > ab) {
                    firstErrorMessage = `Player ${name}: Hits (H) plus Strikeouts (SO) cannot exceed At-Bats (AB).`; if(row) row.querySelector('.player-so').focus(); break;
                }
            }

            if (firstErrorMessage) {
                showMessage(firstErrorMessage);
                return false;
            }
            return true;
        }

        function loadRosterFromURL() {
            const params = new URLSearchParams(window.location.search);
            const rosterData = params.get('roster');
            if (rosterData) {
                try {
                    const decodedRoster = JSON.parse(atob(rosterData));
                    if (Array.isArray(decodedRoster)) {
                        const validatedRoster = decodedRoster.map(p => ({ 
                            name: p.name || '',
                            ab: p.ab === undefined || p.ab === null ? '' : p.ab,
                            h:  p.h  === undefined || p.h  === null ? '' : p.h,
                            tb: p.tb === undefined || p.tb === null ? '' : p.tb,
                            so: p.so === undefined || p.so === null ? '' : p.so,
                        })).filter(p => { 
                            const abNum = p.ab === '' ? null : parseInt(p.ab); 
                            const hNum = p.h === '' ? null : parseInt(p.h);
                            const tbNum = p.tb === '' ? null : parseInt(p.tb); 
                            const soNum = p.so === '' ? null : parseInt(p.so);
                            return !( (abNum !== null && (isNaN(abNum) || abNum < 0)) ||
                                      (hNum !== null && (isNaN(hNum) || hNum < 0)) ||
                                      (tbNum !== null && (isNaN(tbNum) || tbNum < 0)) ||
                                      (soNum !== null && (isNaN(soNum) || soNum < 0)) ||
                                      (abNum !== null && hNum !== null && hNum > abNum) ||
                                      (hNum !== null && tbNum !== null && tbNum < hNum) ||
                                      (abNum !== null && soNum !== null && soNum > abNum) ||
                                      (abNum !== null && hNum !== null && soNum !== null && (hNum + soNum) > abNum)
                                    );
                        });

                        if (validatedRoster.length !== decodedRoster.length) {
                            showMessage("Some player data from the URL was invalid or incomplete and has been omitted/adjusted.");
                        }

                        if (validatedRoster.length > 0) {
                            globalRoster = validatedRoster;
                            renderRosterFromGlobal();
                            saveRosterToLocalStorage(); 
                            showMessage("Roster loaded from URL!");
                            window.history.replaceState({}, document.title, window.location.pathname);
                            return; 
                        } else if (decodedRoster.length > 0) {
                             showMessage("Roster data in URL was invalid. Loading from local storage instead.");
                        }
                    } else {
                         showMessage("Invalid roster format in URL. Loading from local storage instead.");
                    }
                } catch (e) {
                    console.error("Error parsing roster data from URL:", e);
                    showMessage("Could not load roster from URL: Corrupted data. Loading from local storage.");
                }
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            loadRosterFromLocalStorage();
        }
        
        generateShareUrlBtn.addEventListener('click', () => {
            if (!validateRosterForProcessing()) { 
                 showMessage("Please ensure all player data is complete and valid before generating a share URL.");
                 return;
            }
            if (globalRoster.length === 0) {
                showMessage("Roster is empty. Add players to share.");
                return;
            }
            const jsonRoster = JSON.stringify(globalRoster);
            const base64Roster = btoa(jsonRoster); 
            const url = `${window.location.origin}${window.location.pathname}?roster=${base64Roster}`;
            shareUrlInput.value = url;
        });

        copyUrlBtn.addEventListener('click', () => {
            if (shareUrlInput.value) {
                shareUrlInput.select();
                try {
                    document.execCommand('copy'); 
                    showMessage("URL copied to clipboard!");
                } catch (err) {
                    navigator.clipboard.writeText(shareUrlInput.value).then(() => {
                        showMessage("URL copied to clipboard!");
                    }).catch(e => {
                        showMessage("Failed to copy URL. Please copy it manually.");
                        console.error("Copy failed: ", e);
                    });
                }
            } else {
                showMessage("Generate a URL first.");
            }
        });

        // --- Probability Calculation ---
        function calculatePlayerProbs(player) {
            if (!player || typeof player.ab !== 'number' || player.ab === 0 || 
                typeof player.h !== 'number' || typeof player.tb !== 'number' || typeof player.so !== 'number') {
                console.warn("Invalid player data passed to calculatePlayerProbs:", player);
                return { ...player, name: player.name || "Unknown Player", P_SO: 0, P_Out_Other: 1, P_1B: 0, P_2B: 0, P_HR: 0, C_SO: 0, C_Out_Other: 1, C_1B: 1, C_2B: 1, C_HR: 1 };
            }

            let { ab, h, tb, so } = player; 

            const avg = h / ab;
            const slg = tb / ab;
            let iso = slg - avg;
            if (iso < 0) iso = 0; 

            let p_hr = 0, p_2b = 0, p_1b = 0;

            if (avg > 0) { 
                const alpha_hr_vs_2b_bases = 3.0; 
                p_hr = iso / (alpha_hr_vs_2b_bases + 1.0); 
                p_2b = iso - 3 * p_hr; 
                
                if (p_2b < 0) { 
                    p_hr = iso / 3.0; 
                    p_2b = 0;
                }

                if (p_hr + p_2b > avg) {
                    const total_xbh_prob_raw = p_hr + p_2b;
                    if (total_xbh_prob_raw > 0) {
                        const target_xbh_sum = avg * 0.9; 
                        const scale_xbh = Math.min(1, (total_xbh_prob_raw > 1e-9 ? target_xbh_sum / total_xbh_prob_raw : 0) );
                        p_hr *= scale_xbh;
                        p_2b *= scale_xbh;
                    } else {
                        p_hr = 0; p_2b = 0;
                    }
                }
                
                p_1b = avg - p_hr - p_2b;

                p_hr = Math.max(0, p_hr);
                p_2b = Math.max(0, p_2b);
                p_1b = Math.max(0, avg - p_hr - p_2b); // Recalculate p_1b after adjustments

                const current_sum_hit_probs = p_1b + p_2b + p_hr;
                if (current_sum_hit_probs > 1e-9 && avg > 1e-9 && Math.abs(current_sum_hit_probs - avg) > 1e-9) {
                    const scale = avg / current_sum_hit_probs;
                    p_1b *= scale;
                    p_2b *= scale;
                    p_hr *= scale;
                } else if (avg > 1e-9 && current_sum_hit_probs < 1e-9) { 
                    p_1b = avg; 
                    p_2b = 0;
                    p_hr = 0;
                }
            }
            
            let p_so_calc = so / ab;
            let p_other_out_calc = (ab - h - so) / ab;

            p_so_calc = Math.max(0, p_so_calc);
            p_other_out_calc = Math.max(0, p_other_out_calc);
            
            let total_non_hit_prob = p_so_calc + p_other_out_calc;
            let target_non_hit_prob = 1.0 - avg;
            target_non_hit_prob = Math.max(0, target_non_hit_prob); // Cannot be negative

            if (Math.abs(total_non_hit_prob - target_non_hit_prob) > 1e-9) {
                if (total_non_hit_prob > 1e-9) {
                    p_so_calc = (p_so_calc / total_non_hit_prob) * target_non_hit_prob;
                    p_other_out_calc = (p_other_out_calc / total_non_hit_prob) * target_non_hit_prob;
                } else if (target_non_hit_prob > 1e-9) { 
                    const original_other_outs = Math.max(0, ab - h - so);
                    if (so + original_other_outs > 1e-9) {
                        p_so_calc = (so / (so + original_other_outs)) * target_non_hit_prob;
                        p_other_out_calc = (original_other_outs / (so + original_other_outs)) * target_non_hit_prob;
                    } else { 
                         p_so_calc = 0; p_other_out_calc = target_non_hit_prob; // If SO and other_outs are 0, all non-hit is other_out
                    }
                } else { // target_non_hit_prob is also near zero
                    p_so_calc = 0; p_other_out_calc = 0;
                }
            }
            
            let all_probs_final = [p_1b, p_2b, p_hr, p_so_calc, p_other_out_calc];
            let sum_all_probs_final = all_probs_final.reduce((s, val_p) => s + val_p, 0);

            if (Math.abs(sum_all_probs_final - 1.0) > 1e-9) {
                if (sum_all_probs_final > 1e-9) {
                    const scaleFactor = 1.0 / sum_all_probs_final;
                    p_1b *= scaleFactor;
                    p_2b *= scaleFactor;
                    p_hr *= scaleFactor;
                    p_so_calc *= scaleFactor;
                    p_other_out_calc *= scaleFactor;
                } else { 
                    p_other_out_calc = 1.0; 
                    p_1b = p_2b = p_hr = p_so_calc = 0;
                }
            }
            p_other_out_calc = Math.max(0, 1.0 - (p_1b + p_2b + p_hr + p_so_calc));


            return {
                ...player, 
                P_SO: p_so_calc, P_Out_Other: p_other_out_calc, P_1B: p_1b, P_2B: p_2b, P_HR: p_hr,
                C_SO: p_so_calc,
                C_Out_Other: p_so_calc + p_other_out_calc,
                C_1B: p_so_calc + p_other_out_calc + p_1b,
                C_2B: p_so_calc + p_other_out_calc + p_1b + p_2b,
                C_HR: 1.0 
            };
        }


        // --- Game Simulation Logic ---
        function getPAOutcome(playerProbs) {
            const r = Math.random();
            if (r < playerProbs.C_SO) return "SO";
            if (r < playerProbs.C_Out_Other) return "OutOther";
            if (r < playerProbs.C_1B) return "1B";
            if (r < playerProbs.C_2B) return "2B";
            return "HR"; 
        }

        function simulateGame(lineupWithProbs) {
            if (!lineupWithProbs || lineupWithProbs.length === 0) return 0;

            let totalGameRuns = 0;
            let currentBatterIdx = 0;

            for (let inning = 0; inning < NUM_INNINGS; inning++) {
                let outs = 0;
                let inningRuns = 0;
                let bases = [0, 0, 0]; // 0:1st, 1:2nd, 2:3rd. Value 1 if occupied, 0 if not.

                while (outs < 3 && inningRuns < MAX_RUNS_PER_INNING) {
                    if (lineupWithProbs.length === 0) break; 
                    const batterProbs = lineupWithProbs[currentBatterIdx % lineupWithProbs.length];
                    const outcome = getPAOutcome(batterProbs);
                    let runsThisPA = 0;

                    if (outcome === "SO" || outcome === "OutOther") {
                        outs++;
                    } else { 
                        const batterId = 1; // Represents the batter becoming a runner
                        if (outcome === "HR") {
                            runsThisPA++; // Batter scores
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } 
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } 
                            if (bases[0]) { runsThisPA++; bases[0] = 0; } 
                        } else if (outcome === "2B") {
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } 
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } 
                            if (bases[0]) { bases[2] = bases[0]; bases[0] = 0; } // Runner from 1st to 3rd
                            bases[1] = batterId; // Batter to 2nd
                        } else if (outcome === "1B") {
                             // Advance runners one base if forced, score from 3rd on any hit
                            if (bases[2]) { runsThisPA++; bases[2] = 0; }
                            if (bases[1]) { bases[2] = bases[1]; bases[1] = 0; }
                            if (bases[0]) { bases[1] = bases[0]; bases[0] = 0; }
                            bases[0] = batterId; // Batter to 1st
                        }
                    }
                    
                    inningRuns += runsThisPA;
                    if (inningRuns >= MAX_RUNS_PER_INNING) {
                        inningRuns = MAX_RUNS_PER_INNING; 
                        // totalGameRuns is accumulated *after* the inning loop, or here if capped.
                        // currentBatterIdx is advanced after PA, before checking run cap for break.
                    }
                    currentBatterIdx = (currentBatterIdx + 1); 
                    if (inningRuns >= MAX_RUNS_PER_INNING) {
                         break; // Inning ends immediately
                    }
                } 
                totalGameRuns += inningRuns; // Add inning's runs (possibly capped) to game total
            } 
            return totalGameRuns;
        }
        
        async function runManySimulationsForAverage(lineup, numSims) { // Renamed for clarity
            return new Promise(resolve => {
                let totalRunsAcrossSims = 0;
                const validatedLineup = lineup.map(p => ({
                    ...p,
                    ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
                }));

                const processedLineup = validatedLineup.map(p => calculatePlayerProbs(p));
                
                if (processedLineup.some(p => !p || typeof p.P_SO === 'undefined')) {
                    console.error("Invalid player data found in lineup during simulation batch:", processedLineup.filter(p => !p || typeof p.P_SO === 'undefined'));
                    // showMessage("Error: Invalid player data detected. Cannot run simulations."); // Already handled by validateRosterForProcessing
                    resolve({ average: 0, counts: {} }); // Return object
                    return;
                }
                
                const runCounts = {}; // For main simulation, we need counts too
                for (let i = 0; i < numSims; i++) {
                    const runs = simulateGame(processedLineup);
                    totalRunsAcrossSims += runs;
                    runCounts[runs] = (runCounts[runs] || 0) + 1;
                }
                resolve({ average: totalRunsAcrossSims / numSims, counts: runCounts });
            });
        }

        runSimulationBtn.addEventListener('click', async () => {
            if (!validateRosterForProcessing()) return; 
            
            const rosterForSim = globalRoster.map(p => ({
                ...p,
                ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
            }));

            const numSimulations = parseInt(numSimulationsSelect.value); // Get selected number of simulations

            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = `Simulating ${numSimulations.toLocaleString()} games... This may take a moment.`;
            simulationResultsDiv.classList.add('hidden'); 
            runSimulationBtn.disabled = true;
            optimizeLineupBtn.disabled = true; 

            await new Promise(resolve => setTimeout(resolve, 100)); // Increased timeout for UI to update with new text

            // For the main simulation, we want to run all sims in one go if possible for speed,
            // but for very large numbers, batching is safer. Let's use a simpler loop for now and
            // rely on the async nature of the overall function for UI responsiveness.
            // The batching in the original was more for UI updates during the loop.
            // Here, we'll get all results then update UI.

            let totalRunsAccumulated = 0;
            const runCounts = {};
            const processedRoster = rosterForSim.map(p => calculatePlayerProbs(p));

            if (processedRoster.some(p => !p || typeof p.P_SO === 'undefined')) { 
                 showMessage("Error processing player data. Please check inputs.");
                 loadingIndicator.style.display = 'none';
                 runSimulationBtn.disabled = false;
                 optimizeLineupBtn.disabled = false;
                 return;
            }
            
            // Simpler loop for main simulation, can be slow for huge numbers without true workers
            // Consider re-adding batching with UI updates if numSimulations gets very large (e.g., > 500k)
            const simBatchSize = 10000; // How many sims before a brief pause for UI
            let simsCompleted = 0;

            async function runSimulationBatches() {
                while(simsCompleted < numSimulations) {
                    const currentBatchEnd = Math.min(simsCompleted + simBatchSize, numSimulations);
                    for (let i = simsCompleted; i < currentBatchEnd; i++) {
                        const runs = simulateGame(processedRoster);
                        totalRunsAccumulated += runs;
                        runCounts[runs] = (runCounts[runs] || 0) + 1;
                    }
                    simsCompleted = currentBatchEnd;
                    loadingIndicator.textContent = `Simulating... ${((simsCompleted / numSimulations) * 100).toFixed(0)}% complete.`;
                    await new Promise(resolve => setTimeout(resolve, 0)); // Yield to event loop
                }

                // --- All simulations complete, now update UI ---
                loadingIndicator.style.display = 'none';
                const expectedRuns = totalRunsAccumulated / numSimulations;
                expectedRunsPerGameValue.textContent = expectedRuns.toFixed(3); // Display expected runs

                const labels = [];
                const data = [];
                runPercentagesTableBody.innerHTML = ''; 

                let practicalMaxRuns = 0;
                for (const runs in runCounts) {
                    if (runCounts[runs] > 0) {
                        practicalMaxRuns = Math.max(practicalMaxRuns, parseInt(runs));
                    }
                }
                const displayMaxRuns = Math.max(15, practicalMaxRuns);

                for (let i = 0; i <= displayMaxRuns; i++) {
                    const count = runCounts[i] || 0;
                    labels.push(i.toString());
                    data.push(count);
                    // Always add to table if it's in the display range, even if count is 0, for consistency
                    const percentage = ((count / numSimulations) * 100).toFixed(2);
                    const row = runPercentagesTableBody.insertRow();
                    row.innerHTML = `<td>${i}</td><td>${count}</td><td>${percentage}%</td>`;
                }
                
                if (runsChart) { runsChart.destroy(); }
                runsChart = new Chart(runsHistogramChartCtx, {
                    type: 'bar',
                    data: { labels: labels, datasets: [{ label: 'Frequency of Runs Scored', data: data, backgroundColor: 'rgba(59, 130, 246, 0.7)', borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1 }] },
                    options: { scales: { y: { beginAtZero: true, title: { display: true, text: 'Number of Games' } }, x: { title: { display: true, text: 'Runs Scored in a Game' } } }, responsive: true, maintainAspectRatio: false }
                });

                simulationResultsDiv.classList.remove('hidden');
                runSimulationBtn.disabled = false;
                optimizeLineupBtn.disabled = false;
            }

            runSimulationBatches(); // Start the simulation batches
        });

        // --- Lineup Optimization ---
        // The runManySimulations function for optimization doesn't need to return counts, just average.
        async function runManySimulationsForOptimization(lineup, numSims) {
            return new Promise(resolve => {
                let totalRunsAcrossSims = 0;
                const validatedLineup = lineup.map(p => ({
                    ...p,
                    ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
                }));
                const processedLineup = validatedLineup.map(p => calculatePlayerProbs(p));
                
                if (processedLineup.some(p => !p || typeof p.P_SO === 'undefined')) {
                    resolve(0); return; // Error case
                }
                for (let i = 0; i < numSims; i++) {
                    totalRunsAcrossSims += simulateGame(processedLineup);
                }
                resolve(totalRunsAcrossSims / numSims);
            });
        }
        
        function getAllPermutations(arr) { 
            if (arr.length === 0) return [[]];
            if (arr.length === 1) return [[...arr]]; 
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const current = arr[i];
                const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
                const remainingPermuted = getAllPermutations(remaining);
                for (let j = 0; j < remainingPermuted.length; j++) {
                    result.push([current, ...remainingPermuted[j]]);
                }
            }
            return result;
        }
        
        optimizeLineupBtn.addEventListener('click', async () => {
            if (!validateRosterForProcessing()) return; 

            const rosterForOpt = globalRoster.map(p => ({ 
                ...p,
                ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
            }));

            if (rosterForOpt.length < 1) { 
                showMessage("Optimization requires at least one player.");
                return;
            }

            const numPlayers = rosterForOpt.length;
            const simsPerLineup = parseInt(optimizationSimsSelect.value);

            if (numPlayers > MAX_BRUTE_FORCE_OPTIMIZATION_SIZE && numPlayers * numPlayers * simsPerLineup > 2000000) { 
                 if (!confirm(`Optimizing a roster of ${numPlayers} players with ${simsPerLineup} simulations per lineup might take a very long time (potentially minutes). Continue?`)) {
                    return;
                }
            }

            optimizationLoadingIndicator.style.display = 'block';
            optimizationResultDiv.classList.add('hidden');
            optimizeLineupBtn.disabled = true;
            runSimulationBtn.disabled = true; 
            
            await new Promise(resolve => setTimeout(resolve, 50)); 

            let bestLineup = [];
            let bestExpectedRuns = -1;
            
            if (numPlayers === 1) {
                bestLineup = [...rosterForOpt]; 
                bestExpectedRuns = await runManySimulationsForOptimization(bestLineup, simsPerLineup);
            } else if (numPlayers <= MAX_BRUTE_FORCE_OPTIMIZATION_SIZE) {
                const permutations = getAllPermutations(rosterForOpt);
                const numPerms = permutations.length; 
                optimizationLoadingIndicator.textContent = `Optimizing (brute force, ${numPerms.toLocaleString()} permutations)... This may take time.`;
                let processedCount = 0;
                for (const perm of permutations) {
                    const avgRuns = await runManySimulationsForOptimization(perm, simsPerLineup);
                    if (avgRuns > bestExpectedRuns) {
                        bestExpectedRuns = avgRuns;
                        bestLineup = perm; 
                    }
                    processedCount++;
                    if (processedCount % Math.max(1, Math.floor(numPerms/50)) === 0 || processedCount === numPerms) { // Update more frequently for many perms
                         optimizationLoadingIndicator.textContent = `Optimizing (brute force)... ${((processedCount/numPerms)*100).toFixed(0)}%`;
                         await new Promise(resolve => setTimeout(resolve, 0)); 
                    }
                }
            } else {
                optimizationLoadingIndicator.textContent = `Optimizing (heuristic search for ${numPlayers} players)... This may take time.`;
                let currentLineup = [...rosterForOpt]; 
                for (let i = currentLineup.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentLineup[i], currentLineup[j]] = [currentLineup[j], currentLineup[i]];
                }

                bestLineup = [...currentLineup];
                bestExpectedRuns = await runManySimulationsForOptimization(currentLineup, simsPerLineup);

                const iterations = Math.min(2000, numPlayers * numPlayers * 4); // Increased iterations for larger rosters
                let noImprovementStreak = 0;
                const maxNoImprovementStreak = Math.max(100, numPlayers * 10); // Increased streak tolerance

                for (let i = 0; i < iterations; i++) {
                    let tempLineup = [...bestLineup]; 
                    const idx1 = Math.floor(Math.random() * tempLineup.length);
                    let idx2 = Math.floor(Math.random() * tempLineup.length);
                    while (idx1 === idx2 && tempLineup.length > 1) { 
                        idx2 = Math.floor(Math.random() * tempLineup.length);
                    }
                    [tempLineup[idx1], tempLineup[idx2]] = [tempLineup[idx2], tempLineup[idx1]]; 
                    
                    const tempAvgRuns = await runManySimulationsForOptimization(tempLineup, simsPerLineup);
                    if (tempAvgRuns > bestExpectedRuns) {
                        bestExpectedRuns = tempAvgRuns;
                        bestLineup = [...tempLineup];
                        noImprovementStreak = 0; 
                    } else {
                        noImprovementStreak++;
                    }

                    if (i % 50 === 0 || i === iterations -1) { // Update UI periodically
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Iteration ${i+1}/${iterations}`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 
                    }
                    if (noImprovementStreak > maxNoImprovementStreak) {
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Converged after ${i+1} iterations.`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 
                        break; 
                    }
                }
            }

            optimizedLineupList.innerHTML = '';
            if (bestLineup && bestLineup.length > 0) {
                bestLineup.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = player.name || "Unnamed Player"; 
                    optimizedLineupList.appendChild(li);
                });
                expectedRunsValue.textContent = bestExpectedRuns.toFixed(3);
            } else {
                 expectedRunsValue.textContent = "N/A";
                 optimizedLineupList.innerHTML = '<li>No valid lineup found.</li>';
            }
            
            optimizationResultDiv.classList.remove('hidden');
            optimizationLoadingIndicator.style.display = 'none';
            optimizationLoadingIndicator.textContent = 'Optimizing... This could take some time.'; 
            optimizeLineupBtn.disabled = false;
            runSimulationBtn.disabled = false;
        });

        // --- Initialization ---
        addPlayerBtn.addEventListener('click', () => {
            globalRoster.push({ name: '', ab: '', h: '', tb: '', so: '' });
            renderRosterFromGlobal(); 
            saveRosterToLocalStorage(); 
            if(rosterTableBody.lastElementChild) {
                const lastRowInputs = rosterTableBody.lastElementChild.querySelectorAll('input');
                if (lastRowInputs.length > 0) {
                    lastRowInputs[0].focus();
                }
            }
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            loadRosterFromURL(); 
        });

    </script>
</body>
</html>
