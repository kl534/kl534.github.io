<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Little League Stat Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1f2937; /* Dark gray */
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb; /* Light gray border */
            padding-bottom: 0.5rem;
        }
        label {
            font-weight: 500;
            color: #374151; /* Medium gray */
        }
        input[type="text"], input[type="number"], select {
            border: 1px solid #d1d5db; /* Gray border */
            border-radius: 4px;
            padding: 8px 12px;
            width: 100%;
            margin-top: 4px;
            box-sizing: border-box;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none; /* Safari and Chrome */
            margin: 0;
        }

        /* General Button Styling */
        button, .button-like { 
            background-color: #3b82f6; /* Blue */
            color: white;
            font-weight: 500;
            padding: 12px 18px; /* Increased padding */
            border-radius: 6px;
            border: 1px solid #2563eb; 
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s, transform 0.1s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            text-align: center; /* Ensure text is centered */
        }
        button:hover, .button-like:hover {
            background-color: #2563eb; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); 
        }
        button:active, .button-like:active {
            transform: translateY(1px); 
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        button:disabled, .button-like:disabled {
            background-color: #9ca3af; 
            border-color: #6b7280;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Specific Button Types */
        .delete-btn {
            background-color: #ef4444; 
            border-color: #dc2626; 
            padding: 6px 10px; /* Keep smaller padding for table buttons */
            font-size: 0.875rem;
        }
        .delete-btn:hover {
            background-color: #dc2626; 
        }

        .move-btn {
            background-color: #6b7280; 
            border-color: #4b5563; 
            padding: 4px 8px; /* Keep smaller padding for table buttons */
            font-size: 0.8rem;
            margin: 0 2px;
        }
        .move-btn:hover {
            background-color: #4b5563; 
        }
        
        .secondary-btn {
            background-color: #6b7280; 
            border-color: #4b5563;
             padding: 10px 15px; /* Standard padding for this type */
        }
        .secondary-btn:hover {
            background-color: #4b5563;
        }


        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }
        th, td {
            border: 1px solid #e5e7eb; 
            padding: 10px;
            text-align: left;
            font-size: 0.9rem;
            vertical-align: middle; 
        }
        th {
            background-color: #f9fafb; 
            font-weight: 600;
        }
        /* Removed .stats-table td as the table itself is removed */
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000; 
        }
        .modal-content {
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            max-width: 90%; 
        }
        #loadingIndicator, #optimizationLoadingIndicator { 
            display: none; 
            margin-top: 1rem;
            font-weight: 500;
            color: #1d4ed8; 
        }
        .chart-container {
            position: relative;
            height: 350px; 
            width: 100%;   
            margin-bottom: 1rem; 
        }
        .order-buttons button {
            min-width: 30px; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Little League Stat Simulator</h1>

        <div class="card">
            <h2>Roster Input</h2>
            <p class="text-sm text-gray-600 mb-3">Enter your players below. The lineup order can be adjusted using the ▲/▼ buttons. Data is saved automatically.</p>
            <table id="rosterTable">
                <thead>
                    <tr>
                        <th>Player Name</th>
                        <th>At-Bats (AB)</th>
                        <th>Hits (H)</th>
                        <th>Total Bases (TB)</th>
                        <th>Strikeouts (SO)</th>
                        <th class="w-24 text-center">Order</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="rosterTableBody">
                </tbody>
            </table>
            <button id="addPlayerBtn" class="mt-4">Add Player</button>
        </div>

        <div class="card">
            <h2>Game Simulation</h2>
            <div class="mb-4">
                <label for="numSimulationsSelect" class="block mb-1">Number of Simulations:</label>
                <select id="numSimulationsSelect">
                    <option value="10000">10,000</option>
                    <option value="50000">50,000</option>
                    <option value="100000" selected>100,000 (Default)</option>
                    <option value="250000">250,000</option>
                    <option value="500000">500,000 (Slower)</option>
                </select>
            </div>
            <button id="runSimulationBtn">Run Simulation</button>
            <div id="loadingIndicator">Simulating... Please wait. This might take a moment.</div>
            <div id="simulationResults" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-2">Run Distribution Histogram</h3>
                <div class="chart-container">
                    <canvas id="runsHistogramChart"></canvas>
                </div>
                <p id="expectedRunsDisplay" class="mt-4 text-lg font-semibold">Expected Runs per Game: <span id="expectedRunsPerGameValue" class="text-blue-700"></span></p>
                </div>
        </div>

        <div class="card">
            <h2>Lineup Optimization</h2>
            <div>
                <label for="optimizationSimsSelect" class="block mb-1">Simulations per Lineup:</label>
                <select id="optimizationSimsSelect">
                    <option value="100">100 (Fastest)</option>
                    <option value="500">500</option>
                    <option value="1000" selected>1000 (Recommended)</option>
                    <option value="2000">2000</option> 
                    <option value="5000">5000 (Most Accurate)</option>
                </select>
            </div>
            <button id="optimizeLineupBtn" class="mt-4">Optimize Lineup</button>
            <div id="optimizationLoadingIndicator">Optimizing... This could take some time.</div>
            <div id="optimizationResult" class="mt-4 hidden">
                <h3 class="text-xl font-semibold mb-1">Optimized Lineup:</h3>
                <ol id="optimizedLineupList" class="list-decimal list-inside pl-2 bg-gray-50 p-3 rounded"></ol>
                <p class="mt-2 font-semibold">Expected Runs: <span id="expectedRunsValue" class="text-blue-700"></span></p>
            </div>
        </div>

        <div class="card">
            <h2>Share Roster</h2>
            <button id="generateShareUrlBtn">Generate Shareable URL</button>
            <div class="mt-2 flex items-center space-x-2">
                <input type="text" id="shareUrlInput" readonly class="bg-gray-100 flex-grow">
                <button id="copyUrlBtn" class="secondary-btn">Copy URL</button> 
            </div>
        </div>
    </div>

    <div id="messageModal" class="modal hidden">
        <div class="modal-content">
            <p id="modalMessageText"></p>
            <button id="closeModalBtn" class="mt-4">Close</button> 
        </div>
    </div>

    <script>
        // --- Global State & Constants ---
        let globalRoster = [];
        let runsChart = null;
        const MAX_RUNS_PER_INNING = 5;
        const NUM_INNINGS = 6;
        const MAX_BRUTE_FORCE_OPTIMIZATION_SIZE = 8;

        // --- DOM Elements ---
        const rosterTableBody = document.getElementById('rosterTableBody');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const numSimulationsSelect = document.getElementById('numSimulationsSelect');
        const runSimulationBtn = document.getElementById('runSimulationBtn');
        const simulationResultsDiv = document.getElementById('simulationResults');
        const runsHistogramChartCtx = document.getElementById('runsHistogramChart').getContext('2d');
        const expectedRunsDisplay = document.getElementById('expectedRunsDisplay'); // Element to scroll to
        const expectedRunsPerGameValue = document.getElementById('expectedRunsPerGameValue'); 
        // runPercentagesTableBody is no longer needed
        const optimizationSimsSelect = document.getElementById('optimizationSimsSelect');
        const optimizeLineupBtn = document.getElementById('optimizeLineupBtn');
        const optimizationResultDiv = document.getElementById('optimizationResult');
        const optimizedLineupList = document.getElementById('optimizedLineupList');
        const expectedRunsValue = document.getElementById('expectedRunsValue');
        const generateShareUrlBtn = document.getElementById('generateShareUrlBtn');
        const shareUrlInput = document.getElementById('shareUrlInput');
        const copyUrlBtn = document.getElementById('copyUrlBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const optimizationLoadingIndicator = document.getElementById('optimizationLoadingIndicator');
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const closeModalBtn = document.getElementById('closeModalBtn');

        // --- Utility Functions ---
        function showMessage(message) {
            modalMessageText.textContent = message;
            messageModal.classList.remove('hidden');
        }
        function hideMessage() {
            messageModal.classList.add('hidden');
        }
        closeModalBtn.addEventListener('click', hideMessage);

        // --- Roster Management ---
        function addPlayerRow(player = { name: '', ab: '', h: '', tb: '', so: '' }, index = -1) {
            const row = rosterTableBody.insertRow(index); 
            const name = player.name || '';
            const ab = player.ab === undefined || player.ab === null ? '' : player.ab;
            const h = player.h === undefined || player.h === null ? '' : player.h;
            const tb = player.tb === undefined || player.tb === null ? '' : player.tb;
            const so = player.so === undefined || player.so === null ? '' : player.so;

            row.innerHTML = `
                <td><input type="text" class="player-name" value="${name}" placeholder="Player Name"></td>
                <td><input type="number" class="player-ab" value="${ab}" placeholder="e.g. 100" min="0"></td>
                <td><input type="number" class="player-h" value="${h}" placeholder="e.g. 30" min="0"></td>
                <td><input type="number" class="player-tb" value="${tb}" placeholder="e.g. 50" min="0"></td>
                <td><input type="number" class="player-so" value="${so}" placeholder="e.g. 20" min="0"></td>
                <td class="text-center order-buttons">
                    <button class="move-btn move-up-btn" title="Move Up">▲</button>
                    <button class="move-btn move-down-btn" title="Move Down">▼</button>
                </td>
                <td><button class="delete-btn">Delete</button></td>
            `;
            
            const currentRowIndex = Array.from(rosterTableBody.rows).indexOf(row);

            row.querySelector('.move-up-btn').addEventListener('click', () => movePlayer(currentRowIndex, -1));
            row.querySelector('.move-down-btn').addEventListener('click', () => movePlayer(currentRowIndex, 1));
            
            row.querySelector('.delete-btn').addEventListener('click', () => {
                deletePlayerRow(row);
            });

            row.querySelectorAll('input').forEach(input => {
                input.addEventListener('change', () => {
                    validateRowOnInputChange(row); 
                    readTableIntoGlobalRoster(); 
                    saveRosterToLocalStorage(); 
                });
                input.addEventListener('keyup', () => { 
                    readTableIntoGlobalRoster();
                    saveRosterToLocalStorage();
                });
            });
        }
        
        function validateRowOnInputChange(row) {
            const nameInput = row.querySelector('.player-name');
            const abInput = row.querySelector('.player-ab');
            const hInput = row.querySelector('.player-h');
            const tbInput = row.querySelector('.player-tb');
            const soInput = row.querySelector('.player-so');
            const name = nameInput.value.trim();
            const ab = abInput.value !== '' ? parseInt(abInput.value) : null;
            const h = hInput.value !== '' ? parseInt(hInput.value) : null;
            const tb = tbInput.value !== '' ? parseInt(tbInput.value) : null;
            const so = soInput.value !== '' ? parseInt(soInput.value) : null;
            let issueFound = false; 

            if (ab !== null && ab < 0) { showMessage(`Player ${name || 'Unnamed'}: At-Bats (AB) must be non-negative.`); issueFound = true; abInput.focus();}
            else if (h !== null && h < 0) { showMessage(`Player ${name || 'Unnamed'}: Hits (H) must be non-negative.`); issueFound = true; hInput.focus();}
            else if (tb !== null && tb < 0) { showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be non-negative.`); issueFound = true; tbInput.focus();}
            else if (so !== null && so < 0) { showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) must be non-negative.`); issueFound = true; soInput.focus();}
            else if (ab !== null && h !== null && h > ab) {
                showMessage(`Player ${name || 'Unnamed'}: Hits (H) cannot exceed At-Bats (AB).`); hInput.focus(); issueFound = true;
            }
            else if (h !== null && tb !== null && tb < h) {
                showMessage(`Player ${name || 'Unnamed'}: Total Bases (TB) must be at least Hits (H).`); tbInput.focus(); issueFound = true;
            }
            else if (ab !== null && so !== null && so > ab) {
                showMessage(`Player ${name || 'Unnamed'}: Strikeouts (SO) cannot exceed At-Bats (AB).`); soInput.focus(); issueFound = true;
            }
            else if (ab !== null && h !== null && so !== null && (h + so) > ab) { 
                 showMessage(`Player ${name || 'Unnamed'}: Hits (H) plus Strikeouts (SO) cannot exceed At-Bats (AB).`); soInput.focus(); issueFound = true;
            }
            return !issueFound; 
        }

        function movePlayer(rowIndex, direction) {
            if (direction === -1 && rowIndex > 0) { 
                [globalRoster[rowIndex], globalRoster[rowIndex - 1]] = [globalRoster[rowIndex - 1], globalRoster[rowIndex]];
            } else if (direction === 1 && rowIndex < globalRoster.length - 1) { 
                [globalRoster[rowIndex], globalRoster[rowIndex + 1]] = [globalRoster[rowIndex + 1], globalRoster[rowIndex]];
            }
            renderRosterFromGlobal(); 
            saveRosterToLocalStorage();
        }

        function deletePlayerRow(rowElement) {
            const rowIndex = Array.from(rosterTableBody.rows).indexOf(rowElement);
            if (rowIndex > -1) {
                globalRoster.splice(rowIndex, 1); 
                renderRosterFromGlobal(); 
                saveRosterToLocalStorage();
            }
        }
        
        function readTableIntoGlobalRoster() {
            const newRoster = [];
            const rows = rosterTableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const name = rows[i].querySelector('.player-name').value.trim();
                const abStr = rows[i].querySelector('.player-ab').value;
                const hStr = rows[i].querySelector('.player-h').value;
                const tbStr = rows[i].querySelector('.player-tb').value;
                const soStr = rows[i].querySelector('.player-so').value;
                newRoster.push({
                    name: name,
                    ab: abStr === '' ? '' : parseInt(abStr), 
                    h:  hStr === '' ? '' : parseInt(hStr),
                    tb: tbStr === '' ? '' : parseInt(tbStr),
                    so: soStr === '' ? '' : parseInt(soStr),
                });
            }
            globalRoster = newRoster;
        }
        
        function renderRosterFromGlobal() {
            rosterTableBody.innerHTML = ''; 
            if (globalRoster.length === 0) { 
                addPlayerRow(); 
            } else {
                globalRoster.forEach((player, index) => {
                    addPlayerRow(player, index);
                });
            }
            updateMoveButtonStates();
        }

        function updateMoveButtonStates() {
            const rows = rosterTableBody.rows;
            for (let i = 0; i < rows.length; i++) {
                const upBtn = rows[i].querySelector('.move-up-btn');
                const downBtn = rows[i].querySelector('.move-down-btn');
                if (upBtn) upBtn.disabled = (i === 0);
                if (downBtn) downBtn.disabled = (i === rows.length - 1);
            }
        }

        function saveRosterToLocalStorage() {
            localStorage.setItem('littleLeagueRoster', JSON.stringify(globalRoster));
        }

        function loadRosterFromLocalStorage() {
            const savedRoster = localStorage.getItem('littleLeagueRoster');
            if (savedRoster) {
                try {
                    const parsedRoster = JSON.parse(savedRoster);
                    if (Array.isArray(parsedRoster)) {
                        globalRoster = parsedRoster.map(p => ({ 
                            name: p.name || '',
                            ab: p.ab === undefined || p.ab === null ? '' : p.ab,
                            h:  p.h  === undefined || p.h  === null ? '' : p.h,
                            tb: p.tb === undefined || p.tb === null ? '' : p.tb,
                            so: p.so === undefined || p.so === null ? '' : p.so,
                        }));
                    } else { globalRoster = []; } 
                } catch (e) {
                    console.error("Error parsing roster from local storage:", e);
                    globalRoster = []; 
                }
            }
            renderRosterFromGlobal(); 
        }

        function validateRosterForProcessing() {
            readTableIntoGlobalRoster(); 
            if (globalRoster.length === 0) {
                showMessage("Roster is empty. Please add players first.");
                return false;
            }
            let firstErrorMessage = "";
            let firstErrorField = null;

            for (let i = 0; i < globalRoster.length; i++) {
                const player = globalRoster[i];
                const row = rosterTableBody.rows[i]; 
                
                if (!player.name.trim()) {
                    firstErrorMessage = "One or more players is missing a name.";
                    if(row) firstErrorField = row.querySelector('.player-name');
                    break; 
                }
                const { name, ab, h, tb, so } = player; 
                if (ab === '' || h === '' || tb === '' || so === '') {
                    firstErrorMessage = `Player ${name} has incomplete stats. All fields (AB, H, TB, SO) are required.`;
                    if(row) { 
                        if(ab === '') firstErrorField = row.querySelector('.player-ab');
                        else if(h === '') firstErrorField = row.querySelector('.player-h');
                        else if(tb === '') firstErrorField = row.querySelector('.player-tb');
                        else if(so === '') firstErrorField = row.querySelector('.player-so');
                    }
                    break;
                }
                if (isNaN(ab) || isNaN(h) || isNaN(tb) || isNaN(so)) {
                    firstErrorMessage = `Player ${name} has non-numeric stat entries.`;
                     if(row) { 
                        if(isNaN(ab)) firstErrorField = row.querySelector('.player-ab');
                        else if(isNaN(h)) firstErrorField = row.querySelector('.player-h');
                        else if(isNaN(tb)) firstErrorField = row.querySelector('.player-tb');
                        else if(isNaN(so)) firstErrorField = row.querySelector('.player-so');
                    }
                    break;
                }
                if (Number(ab) < 0 || Number(h) < 0 || Number(tb) < 0 || Number(so) < 0) {
                     firstErrorMessage = `Player ${name}: Stats must be non-negative.`; 
                     if(row) { if(Number(ab) < 0) firstErrorField = row.querySelector('.player-ab'); }
                     break;
                }
                if (Number(h) > Number(ab)) {
                    firstErrorMessage = `Player ${name}: Hits (H) cannot exceed At-Bats (AB).`; if(row) firstErrorField = row.querySelector('.player-h'); break;
                }
                if (Number(tb) < Number(h)) {
                    firstErrorMessage = `Player ${name}: Total Bases (TB) must be at least Hits (H).`; if(row) firstErrorField = row.querySelector('.player-tb'); break;
                }
                if (Number(so) > Number(ab)) {
                    firstErrorMessage = `Player ${name}: Strikeouts (SO) cannot exceed At-Bats (AB).`; if(row) firstErrorField = row.querySelector('.player-so'); break;
                }
                if ((Number(h) + Number(so)) > Number(ab)) {
                    firstErrorMessage = `Player ${name}: Hits (H) plus Strikeouts (SO) cannot exceed At-Bats (AB).`; if(row) firstErrorField = row.querySelector('.player-so'); break;
                }
            }

            if (firstErrorMessage) {
                showMessage(firstErrorMessage);
                if(firstErrorField) firstErrorField.focus();
                return false;
            }
            return true;
        }

        function loadRosterFromURL() {
            const params = new URLSearchParams(window.location.search);
            const rosterData = params.get('roster');
            if (rosterData) {
                try {
                    const decodedRoster = JSON.parse(atob(rosterData));
                    if (Array.isArray(decodedRoster)) {
                        const validatedRoster = decodedRoster.map(p => ({ 
                            name: p.name || '',
                            ab: p.ab === undefined || p.ab === null ? '' : p.ab,
                            h:  p.h  === undefined || p.h  === null ? '' : p.h,
                            tb: p.tb === undefined || p.tb === null ? '' : p.tb,
                            so: p.so === undefined || p.so === null ? '' : p.so,
                        })).filter(p => { 
                            const abNum = p.ab === '' ? null : parseInt(p.ab); 
                            const hNum = p.h === '' ? null : parseInt(p.h);
                            const tbNum = p.tb === '' ? null : parseInt(p.tb); 
                            const soNum = p.so === '' ? null : parseInt(p.so);
                            return !( (abNum !== null && (isNaN(abNum) || abNum < 0)) ||
                                      (hNum !== null && (isNaN(hNum) || hNum < 0)) ||
                                      (tbNum !== null && (isNaN(tbNum) || tbNum < 0)) ||
                                      (soNum !== null && (isNaN(soNum) || soNum < 0)) ||
                                      (abNum !== null && hNum !== null && hNum > abNum) ||
                                      (hNum !== null && tbNum !== null && tbNum < hNum) ||
                                      (abNum !== null && soNum !== null && soNum > abNum) ||
                                      (abNum !== null && hNum !== null && soNum !== null && (hNum + soNum) > abNum)
                                    );
                        });

                        if (validatedRoster.length !== decodedRoster.length) {
                            showMessage("Some player data from the URL was invalid or incomplete and has been omitted/adjusted.");
                        }
                        if (validatedRoster.length > 0) globalRoster = validatedRoster;
                        else if (decodedRoster.length > 0) {
                             showMessage("Roster data in URL was invalid. Loading from local storage instead.");
                             globalRoster = []; 
                        } else globalRoster = [];
                    } else {
                         showMessage("Invalid roster format in URL. Loading from local storage instead.");
                         globalRoster = [];
                    }
                } catch (e) { 
                    console.error("Error parsing roster data from URL:", e);
                    showMessage("Could not load roster from URL: Corrupted data. Loading from local storage.");
                    globalRoster = [];
                }
                window.history.replaceState({}, document.title, window.location.pathname);
            }
            
            if (!rosterData || (rosterData && globalRoster.length === 0 && decodedRoster && decodedRoster.length > 0) || (rosterData && !Array.isArray(globalRoster) )) {
                 loadRosterFromLocalStorage(); // Fallback if URL load fails or results in empty roster from non-empty URL data
            } else {
                 renderRosterFromGlobal(); 
                 saveRosterToLocalStorage(); 
                 if (params.get('roster') && globalRoster.length > 0) showMessage("Roster loaded from URL!");
            }
        }
        
        generateShareUrlBtn.addEventListener('click', () => {
            if (!validateRosterForProcessing()) return;
            if (globalRoster.length === 0) {
                showMessage("Roster is empty. Add players to share.");
                return;
            }
            const jsonRoster = JSON.stringify(globalRoster);
            const base64Roster = btoa(jsonRoster); 
            const url = `${window.location.origin}${window.location.pathname}?roster=${base64Roster}`;
            shareUrlInput.value = url;
            if(url) showMessage("Shareable URL generated!");
        });

        copyUrlBtn.addEventListener('click', () => {
            if (shareUrlInput.value) {
                shareUrlInput.select();
                try {
                    if(document.execCommand('copy')) showMessage("URL copied to clipboard!");
                    else throw new Error('execCommand failed'); 
                } catch (err) {
                    navigator.clipboard.writeText(shareUrlInput.value).then(() => {
                        showMessage("URL copied to clipboard!");
                    }).catch(e => {
                        showMessage("Failed to copy URL. Please copy it manually.");
                        console.error("Copy failed: ", e);
                    });
                }
            } else showMessage("Generate a URL first.");
        });

        // --- Probability Calculation ---
        function calculatePlayerProbs(player) {
            if (!player || typeof player.ab !== 'number' || player.ab === 0 || 
                typeof player.h !== 'number' || typeof player.tb !== 'number' || typeof player.so !== 'number') {
                console.warn("Invalid player data to calculatePlayerProbs:", player);
                return { ...player, name: player.name || "Error Player", P_SO: 0, P_Out_Other: 1, P_1B: 0, P_2B: 0, P_HR: 0, C_SO: 0, C_Out_Other: 1, C_1B: 1, C_2B: 1, C_HR: 1 };
            }
            let { ab, h, tb, so } = player; 
            const avg = h / ab;
            const slg = tb / ab;
            let iso = Math.max(0, slg - avg);
            let p_hr = 0, p_2b = 0, p_1b = 0;

            if (avg > 0) { 
                const alpha_hr_vs_2b_bases = 3.0; 
                p_hr = iso / (alpha_hr_vs_2b_bases + 1.0); 
                p_2b = iso - 3 * p_hr; 
                if (p_2b < 0) { p_hr = iso / 3.0; p_2b = 0; }

                if (p_hr + p_2b > avg) {
                    const total_xbh_prob_raw = p_hr + p_2b;
                    if (total_xbh_prob_raw > 1e-9) {
                        const target_xbh_sum = avg * 0.9; 
                        const scale_xbh = Math.min(1, target_xbh_sum / total_xbh_prob_raw);
                        p_hr *= scale_xbh; p_2b *= scale_xbh;
                    } else { p_hr = 0; p_2b = 0; }
                }
                p_1b = avg - p_hr - p_2b;
                p_hr = Math.max(0, p_hr); p_2b = Math.max(0, p_2b);
                p_1b = Math.max(0, avg - p_hr - p_2b); 

                const current_sum_hit_probs = p_1b + p_2b + p_hr;
                if (current_sum_hit_probs > 1e-9 && avg > 1e-9 && Math.abs(current_sum_hit_probs - avg) > 1e-9) {
                    const scale = avg / current_sum_hit_probs;
                    p_1b *= scale; p_2b *= scale; p_hr *= scale;
                } else if (avg > 1e-9 && current_sum_hit_probs < 1e-9) { 
                    p_1b = avg; p_2b = 0; p_hr = 0;
                }
            }
            
            let p_so_calc = Math.max(0, so / ab);
            let p_other_out_calc = Math.max(0, (ab - h - so) / ab);
            
            let total_out_prob_calculated = p_so_calc + p_other_out_calc;
            let target_total_out_prob = Math.max(0, 1.0 - avg);

            if (Math.abs(total_out_prob_calculated - target_total_out_prob) > 1e-9) {
                if (total_out_prob_calculated > 1e-9) { 
                    const scale_out = target_total_out_prob / total_out_prob_calculated;
                    p_so_calc *= scale_out; p_other_out_calc *= scale_out;
                } else if (target_total_out_prob > 1e-9) { 
                    const original_other_out_count = Math.max(0, ab - h - so);
                    if (so + original_other_out_count > 1e-9) {
                         p_so_calc = (so / (so + original_other_out_count)) * target_total_out_prob;
                         p_other_out_calc = (original_other_out_count / (so + original_other_out_count)) * target_total_out_prob;
                    } else { p_so_calc = 0; p_other_out_calc = target_total_out_prob; }
                } else { p_so_calc = 0; p_other_out_calc = 0; }
            }
            
            p_1b = Math.max(0,p_1b); p_2b = Math.max(0,p_2b); p_hr = Math.max(0,p_hr);
            p_so_calc = Math.max(0,p_so_calc); p_other_out_calc = Math.max(0,p_other_out_calc);

            let all_probs_final = [p_1b, p_2b, p_hr, p_so_calc, p_other_out_calc];
            let sum_all_probs_final = all_probs_final.reduce((s, val_p) => s + val_p, 0);

            if (Math.abs(sum_all_probs_final - 1.0) > 1e-9) { 
                if (sum_all_probs_final > 1e-9) { 
                    const scaleFactor = 1.0 / sum_all_probs_final;
                    p_1b *= scaleFactor; p_2b *= scaleFactor; p_hr *= scaleFactor;
                    p_so_calc *= scaleFactor; p_other_out_calc *= scaleFactor;
                } else { 
                    p_other_out_calc = 1.0; p_1b = p_2b = p_hr = p_so_calc = 0;
                }
            }
            p_other_out_calc = Math.max(0, 1.0 - (p_1b + p_2b + p_hr + p_so_calc));

            return {
                ...player, 
                P_SO: p_so_calc, P_Out_Other: p_other_out_calc, P_1B: p_1b, P_2B: p_2b, P_HR: p_hr,
                C_SO: p_so_calc,
                C_Out_Other: p_so_calc + p_other_out_calc,
                C_1B: p_so_calc + p_other_out_calc + p_1b,
                C_2B: p_so_calc + p_other_out_calc + p_1b + p_2b,
                C_HR: 1.0 
            };
        }

        // --- Game Simulation Logic ---
        function getPAOutcome(playerProbs) {
            const r = Math.random();
            if (r < playerProbs.C_SO) return "SO";
            if (r < playerProbs.C_Out_Other) return "OutOther";
            if (r < playerProbs.C_1B) return "1B";
            if (r < playerProbs.C_2B) return "2B";
            return "HR"; 
        }

        function simulateGame(lineupWithProbs) {
            if (!lineupWithProbs || lineupWithProbs.length === 0) return 0;
            let totalGameRuns = 0;
            let currentBatterIdx = 0;
            for (let inning = 0; inning < NUM_INNINGS; inning++) {
                let outs = 0;
                let inningRuns = 0;
                let bases = [0, 0, 0]; 
                while (outs < 3 && inningRuns < MAX_RUNS_PER_INNING) {
                    if (lineupWithProbs.length === 0) break; 
                    const batterProbs = lineupWithProbs[currentBatterIdx % lineupWithProbs.length];
                    const outcome = getPAOutcome(batterProbs);
                    let runsThisPA = 0;
                    if (outcome === "SO" || outcome === "OutOther") {
                        outs++;
                    } else { 
                        const batterId = 1; 
                        if (outcome === "HR") {
                            runsThisPA++; 
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } 
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } 
                            if (bases[0]) { runsThisPA++; bases[0] = 0; } 
                        } else if (outcome === "2B") {
                            if (bases[2]) { runsThisPA++; bases[2] = 0; } 
                            if (bases[1]) { runsThisPA++; bases[1] = 0; } 
                            if (bases[0]) { bases[2] = bases[0]; bases[0] = 0; } 
                            bases[1] = batterId; 
                        } else if (outcome === "1B") {
                            if (bases[2]) { runsThisPA++; bases[2] = 0; }
                            if (bases[1]) { bases[2] = bases[1]; bases[1] = 0; }
                            if (bases[0]) { bases[1] = bases[0]; bases[0] = 0; }
                            bases[0] = batterId; 
                        }
                    }
                    inningRuns += runsThisPA;
                    if (inningRuns >= MAX_RUNS_PER_INNING) inningRuns = MAX_RUNS_PER_INNING; 
                    currentBatterIdx++; 
                    if (inningRuns >= MAX_RUNS_PER_INNING) break; 
                } 
                totalGameRuns += inningRuns; 
            } 
            return totalGameRuns;
        }
        
        async function runSimulationsAndGetStats(lineup, numSims) { 
            return new Promise(resolve => {
                let totalRunsAccumulated = 0;
                const runCounts = {};
                const validatedLineup = lineup.map(p => ({
                    ...p, 
                    ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
                }));
                const processedLineup = validatedLineup.map(p => calculatePlayerProbs(p));
                if (processedLineup.some(p => !p || typeof p.P_SO === 'undefined')) {
                    console.error("Invalid player data for simulation batch.");
                    resolve({ average: 0, counts: {} }); 
                    return;
                }
                const simBatchSizeInternal = 10000; 
                let simsCompletedInternal = 0;
                async function runBatchInternal() {
                    while(simsCompletedInternal < numSims) {
                        const currentBatchEnd = Math.min(simsCompletedInternal + simBatchSizeInternal, numSims);
                        for (let i = simsCompletedInternal; i < currentBatchEnd; i++) {
                            const runs = simulateGame(processedLineup);
                            totalRunsAccumulated += runs;
                            runCounts[runs] = (runCounts[runs] || 0) + 1;
                        }
                        simsCompletedInternal = currentBatchEnd;
                        if (loadingIndicator.style.display === 'block') {
                             loadingIndicator.textContent = `Simulating... ${((simsCompletedInternal / numSims) * 100).toFixed(0)}% complete.`;
                        }
                        await new Promise(resolveYield => setTimeout(resolveYield, 0)); 
                    }
                    resolve({ average: totalRunsAccumulated / numSims, counts: runCounts });
                }
                runBatchInternal();
            });
        }

        runSimulationBtn.addEventListener('click', async () => {
            if (!validateRosterForProcessing()) return; 
            const rosterForSim = globalRoster.map(p => ({ ...p })); 
            const numSimulations = parseInt(numSimulationsSelect.value); 

            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = `Preparing simulation for ${numSimulations.toLocaleString()} games...`;
            simulationResultsDiv.classList.add('hidden'); 
            runSimulationBtn.disabled = true;
            optimizeLineupBtn.disabled = true; 

            await new Promise(resolve => setTimeout(resolve, 50)); 

            const simResults = await runSimulationsAndGetStats(rosterForSim, numSimulations);
            
            loadingIndicator.style.display = 'none';
            expectedRunsPerGameValue.textContent = simResults.average.toFixed(3); 

            const labels = [];
            const data = [];
            // Removed runPercentagesTableBody population

            let practicalMaxRuns = 0;
            for (const runs in simResults.counts) {
                if (simResults.counts[runs] > 0) {
                    practicalMaxRuns = Math.max(practicalMaxRuns, parseInt(runs));
                }
            }
            const displayMaxRuns = Math.max(15, practicalMaxRuns); 

            for (let i = 0; i <= displayMaxRuns; i++) {
                const count = simResults.counts[i] || 0;
                labels.push(i.toString());
                data.push(count);
                // Table population removed
            }
            
            if (runsChart) { runsChart.destroy(); }
            runsChart = new Chart(runsHistogramChartCtx, {
                type: 'bar',
                data: { labels: labels, datasets: [{ label: 'Frequency of Runs Scored', data: data, backgroundColor: 'rgba(59, 130, 246, 0.7)', borderColor: 'rgba(59, 130, 246, 1)', borderWidth: 1 }] },
                options: { scales: { y: { beginAtZero: true, title: { display: true, text: 'Number of Games' } }, x: { title: { display: true, text: 'Runs Scored in a Game' } } }, responsive: true, maintainAspectRatio: false }
            });

            simulationResultsDiv.classList.remove('hidden');
            // Scroll the expected runs display into view
            if (expectedRunsDisplay) {
                expectedRunsDisplay.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            runSimulationBtn.disabled = false;
            optimizeLineupBtn.disabled = false;
        });

        // --- Lineup Optimization ---
        async function runManySimulationsForOptimization(lineup, numSims) {
            return new Promise(resolve => {
                let totalRunsAcrossSims = 0;
                const processedLineup = lineup.map(p => calculatePlayerProbs(p)); 
                if (processedLineup.some(p => !p || typeof p.P_SO === 'undefined')) {
                    console.error("Error in prob calculation during optimization for lineup:", lineup);
                    resolve(0); return; 
                }
                for (let i = 0; i < numSims; i++) {
                    totalRunsAcrossSims += simulateGame(processedLineup);
                }
                resolve(totalRunsAcrossSims / numSims);
            });
        }
        
        function getAllPermutations(arr) { 
            if (arr.length === 0) return [[]];
            if (arr.length === 1) return [[...arr]]; 
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const current = arr[i];
                const remaining = arr.slice(0, i).concat(arr.slice(i + 1));
                const remainingPermuted = getAllPermutations(remaining);
                for (let j = 0; j < remainingPermuted.length; j++) {
                    result.push([current, ...remainingPermuted[j]]);
                }
            }
            return result;
        }
        
        optimizeLineupBtn.addEventListener('click', async () => {
            if (!validateRosterForProcessing()) return; 
            const rosterForOpt = globalRoster.map(p => ({ 
                ...p, 
                ab: Number(p.ab), h: Number(p.h), tb: Number(p.tb), so: Number(p.so)
            }));
            if (rosterForOpt.length < 1) { 
                showMessage("Optimization requires at least one player."); return;
            }
            const numPlayers = rosterForOpt.length;
            const simsPerLineup = parseInt(optimizationSimsSelect.value);
            if (numPlayers > MAX_BRUTE_FORCE_OPTIMIZATION_SIZE && numPlayers * numPlayers * simsPerLineup > 1500000) { 
                 if (!confirm(`Optimizing a roster of ${numPlayers} players with ${simsPerLineup} simulations per lineup might take a significant amount of time. Continue?`)) return;
            }

            optimizationLoadingIndicator.style.display = 'block';
            optimizationResultDiv.classList.add('hidden');
            optimizeLineupBtn.disabled = true;
            runSimulationBtn.disabled = true; 
            await new Promise(resolve => setTimeout(resolve, 50)); 

            let bestLineup = [];
            let bestExpectedRuns = -1;
            
            if (numPlayers === 1) {
                bestLineup = [...rosterForOpt]; 
                bestExpectedRuns = await runManySimulationsForOptimization(bestLineup, simsPerLineup);
            } else if (numPlayers <= MAX_BRUTE_FORCE_OPTIMIZATION_SIZE) {
                const permutations = getAllPermutations(rosterForOpt); 
                const numPerms = permutations.length; 
                optimizationLoadingIndicator.textContent = `Optimizing (brute force, ${numPerms.toLocaleString()} permutations)...`;
                let processedCount = 0;
                for (const perm of permutations) {
                    const avgRuns = await runManySimulationsForOptimization(perm, simsPerLineup);
                    if (avgRuns > bestExpectedRuns) { bestExpectedRuns = avgRuns; bestLineup = perm; }
                    processedCount++;
                    if (processedCount % Math.max(1, Math.floor(numPerms/50)) === 0 || processedCount === numPerms) { 
                         optimizationLoadingIndicator.textContent = `Optimizing (brute force)... ${((processedCount/numPerms)*100).toFixed(0)}%`;
                         await new Promise(resolve => setTimeout(resolve, 0)); 
                    }
                }
            } else { 
                optimizationLoadingIndicator.textContent = `Optimizing (heuristic search for ${numPlayers} players)...`;
                let currentLineup = [...rosterForOpt]; 
                for (let i = currentLineup.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentLineup[i], currentLineup[j]] = [currentLineup[j], currentLineup[i]];
                }
                bestLineup = [...currentLineup];
                bestExpectedRuns = await runManySimulationsForOptimization(currentLineup, simsPerLineup);
                const iterations = Math.min(2000, numPlayers * numPlayers * 4); 
                let noImprovementStreak = 0;
                const maxNoImprovementStreak = Math.max(100, numPlayers * 10); 
                for (let i = 0; i < iterations; i++) {
                    let tempLineup = [...bestLineup]; 
                    const idx1 = Math.floor(Math.random() * tempLineup.length);
                    let idx2 = Math.floor(Math.random() * tempLineup.length);
                    while (idx1 === idx2 && tempLineup.length > 1) idx2 = Math.floor(Math.random() * tempLineup.length);
                    [tempLineup[idx1], tempLineup[idx2]] = [tempLineup[idx2], tempLineup[idx1]]; 
                    const tempAvgRuns = await runManySimulationsForOptimization(tempLineup, simsPerLineup);
                    if (tempAvgRuns > bestExpectedRuns) {
                        bestExpectedRuns = tempAvgRuns; bestLineup = [...tempLineup]; noImprovementStreak = 0; 
                    } else noImprovementStreak++;
                    if (i % 50 === 0 || i === iterations -1) { 
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Iteration ${i+1}/${iterations}`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 
                    }
                    if (noImprovementStreak > maxNoImprovementStreak) {
                        optimizationLoadingIndicator.textContent = `Optimizing (heuristic search)... Converged after ${i+1} iterations.`;
                        await new Promise(resolve => setTimeout(resolve, 0)); 
                        break; 
                    }
                }
            }

            optimizedLineupList.innerHTML = '';
            if (bestLineup && bestLineup.length > 0) {
                bestLineup.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = player.name || "Unnamed Player"; 
                    optimizedLineupList.appendChild(li);
                });
                expectedRunsValue.textContent = bestExpectedRuns.toFixed(3);
            } else {
                 expectedRunsValue.textContent = "N/A";
                 optimizedLineupList.innerHTML = '<li>No valid lineup found.</li>';
            }
            optimizationResultDiv.classList.remove('hidden');
            optimizationLoadingIndicator.style.display = 'none';
            optimizationLoadingIndicator.textContent = 'Optimizing... This could take some time.'; 
            optimizeLineupBtn.disabled = false;
            runSimulationBtn.disabled = false;
        });

        // --- Initialization ---
        addPlayerBtn.addEventListener('click', () => {
            globalRoster.push({ name: '', ab: '', h: '', tb: '', so: '' });
            renderRosterFromGlobal(); 
            saveRosterToLocalStorage(); 
            if(rosterTableBody.lastElementChild) {
                const lastRowNameInput = rosterTableBody.lastElementChild.querySelector('input.player-name');
                if (lastRowNameInput) lastRowNameInput.focus();
            }
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            loadRosterFromURL(); 
        });

    </script>
</body>
</html>
